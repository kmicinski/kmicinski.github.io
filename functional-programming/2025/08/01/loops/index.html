<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Why Tail-Recursive Functions are Loops</title>
  <meta name="description" content="One story every computing enthusiast should hear is the lesson ofhow loops and tail-recursion are equivalent. We like recursivefunctions because they’re amen...">
  <link rel="shortcut icon" type="image/png" href="/assets/img/favicon.png">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="/functional-programming/2025/08/01/loops/">
  <link rel="alternate" type="application/rss+xml" title="Kristopher Micinski" href="/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Kristopher Micinski</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/blog/">Blog</a>
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/publications/">Publications</a>
          
        
          
        
          
        
          
          <a class="page-link" href="/teaching/">Teaching</a>
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Why Tail-Recursive Functions are Loops</h1>
    

    <p class="post-meta"><time datetime="2025-08-01T00:00:00-04:00" itemprop="datePublished">Aug 1, 2025</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>One story every computing enthusiast should hear is the lesson of
how loops and tail-recursion are equivalent. We like recursive
functions because they’re amenable to induction, and we can derive
them in a way that is in direct correspondence with the definition of
the datatype over which they recur. We like loops because they’re
fast and make intuitive sense as long as variables don’t change in too
tricky a way.</p>

<p>In general, recursive functions are slower than loops because they
push stack frames: the performance of most programs today is dominated
by memory reads/writes. The data we touch the most lives in the
cache–we do <em>not</em> want to evict a ton of stuff from the cache, under
any circumstance. In a direct-style implementation of a recursive
function, the recursive call <em>has</em> to push a stack frame to remember
what to do once the function returns:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>;; Racket
(define (sum l)
  (if (empty? l)
      0
      (+ (first l) (sum (rest l)))))

// C 
int sum(int *l, int length) {
    if (length == 0)
        return 0;
    else
        return l[0] + sum(l + 1, length - 1);
}
</code></pre></div></div>

<p>When we get to <code class="language-plaintext highlighter-rouge">(+ (first l) (sum (rest l)))</code>, we first call <code class="language-plaintext highlighter-rouge">(first
l)</code> (which returns the first element). While we’re making that call,
we have to remember to come back and do <code class="language-plaintext highlighter-rouge">(sum (rest l))</code>–to be fully
precise, we remember that we need to do <code class="language-plaintext highlighter-rouge">(rest l)</code>, then take its
result <code class="language-plaintext highlighter-rouge">x</code> and call <code class="language-plaintext highlighter-rouge">(sum x)</code>, remembering to come back and finally
take <em>that</em> result and add it to the result of <code class="language-plaintext highlighter-rouge">(first l)</code>. The reason
we have to do this is because we need to remember those partial
results (in this case the result of <code class="language-plaintext highlighter-rouge">(first l)</code>): we have to store
them somewhere after all, and each time we make the recursive call, we
need to remember the result of <code class="language-plaintext highlighter-rouge">(first l)</code> from <em>this</em> call–we need
O(n) stack space for a list of size n.</p>

<p>Of course, if we use iteration this all goes away:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>;; Racket
(define (sum l)
  (define x 0)
  (for ([elt l])
    (set! x (+ x elt)))
  x)

// C
int sum(const int *l, int length) {
    int x = 0;
    for (int i = 0; i &lt; length; i++) {
        x += l[i];
    }
    return x;
}
</code></pre></div></div>

<p>We all have an intuitive sense of what the loop is doing: once we hit
the end of the loop, we do <em>not</em> make a recursive call (we never issue
a <code class="language-plaintext highlighter-rouge">call</code> instruction in assembly), we simply <em>jump</em> up to the
beginning of the loop. The key is that <code class="language-plaintext highlighter-rouge">x</code> is being used as an
<em>accumulator</em>, growing a partial result in a <em>bottom-up</em> fashion as
the computation proceeds, eventually yielding the final value at the
end. Instead of keeping partial results on the stack, the loop takes a
<em>constant</em> amount of space but linear time.</p>

<p>In a tail-recursive implementation, the rule is that every recursive
call must be a <em>tail</em> call. Intuitively, a tail call is a call which
is “immediately returned.” More formally, a subexpression of an
expression is in tail position if the return value from that
expression is the return value from the whole expression. For example,
in <code class="language-plaintext highlighter-rouge">(if guard e-t e-f)</code>, both <code class="language-plaintext highlighter-rouge">e-t</code> and <code class="language-plaintext highlighter-rouge">e-f</code> are in tail position,
but the guard is not: after we decide which branch to take, we’re
committed:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(define (foo ...)
  ...
  (if guard
    (f x y ...)
    (g z ...)))
</code></pre></div></div>

<p>Once we finish executing <code class="language-plaintext highlighter-rouge">guard</code>, it would be <em>useless</em> (but
<strong>correct</strong>) to (a) push a stack frame, (b) wait on the result of the
subordinate call, and (c) merely return <em>that same result</em>, because
all we’d be doing is <em>copying</em> the return value from the callee and
propagating it back as the return value of the caller.  Being a tail
call is a syntactic property of a callsite: we (and the compiler) can
easily look at a piece of code and cheaply decide when a call is a
tail call versus not.</p>

<p>This reasoning above generalizes to <em>any</em> call expression in tail
position: <em>because a tail call will necessarily evaluate to its
result, administratively copying it up/down the stack is extensionally
a no-op</em>. Now, the tail-recursive version uses a simple trick I teach
to all of my students: (a) identify an accumulator variable, (b)
instead of computing with the <em>result</em> of the recursive call, compute
with the <em>current accumulator</em>, (c) return the accumulator in the base
case:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>;; Racket
(define (sum l acc) ;; note: acc got added
  (if (empty? l)
      acc ;; this is the *true* return!
      (sum (rest l) (+ acc (first l)))))

// C -- we pass in length manually because we're using arrays
int sum(const int* l, int length, int acc) {
    if (length == 0) return acc;
    return sum(l + 1, length - 1, acc + l[0]);
}
</code></pre></div></div>

<p>Both of these functions are tail recursive: because the only recursive
call to <code class="language-plaintext highlighter-rouge">sum</code> is <em>also</em> the return value from <code class="language-plaintext highlighter-rouge">sum</code> (or, more
directly: because both calls to <code class="language-plaintext highlighter-rouge">sum</code> are in tail position). Since the
compiler knows that these are tail calls, a compiler with tail-call
optimization will ensure that both of these tail calls compile into
<code class="language-plaintext highlighter-rouge">jmp</code> statements–with zero implication on stack usage–rather than
the more burdensome (on the cache, stack, etc.) direct-style
calls. Something that should concern you is this: if the function is
using constant stack space, how are the variables being updated /
represented!? The answer is that the arguments get <strong>stomped over</strong>,
and <strong>mutably updated</strong>, yielding the <em>exact same performance profile
as a loop!</em>.</p>

<p>Now time for an exercise, what about this program, can you convert it
to using tail-recursion?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>;; return a pair (cons cell) of the number of even numbers,
;; and the number of odd numbers.
;; HINT: use multiple accumulators. 
(define (even-odd l)
  (if (empty? l)
      (cons 0 0)
      (let ([v (even-odd (rest l))])
            (if (first l)
                (cons (add1 (car v)) (cdr v))
                (cons (car v) (add1 (cdr v))))))))
</code></pre></div></div>

<p>What about <em>this</em> program?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>;; flattens a tree? into a list
;; It's hard because there are *two* calls to linearize--can you do anything?
(define (linearize t)
  (match t
    ['empty '()]
    [`(node ,v ,t0 ,t1) (append (list v) (linearize t0) (linearize t1))]))
</code></pre></div></div>

<p>One surprising fact is that we can systematically compile <em>any</em>
program so that <em>every</em> call is a tail-call, by completely
transforming the program into <a href="https://matt.might.net/articles/cps-conversion/">continuation-passing-style
(CPS)</a>, this
essentially <em>eliminates</em> the stack. Indeed, some compilers for
functional languages work precisely this way: those languages
<strong>cannot</strong> fall prey to a stack overflow, because they have
essentially traded a monolithic (efficient, array-like) stack for a
deeply-nested stack, strewn throughout the heap—because the
continuations will be heap-allocated and nested. There are various
exciting trade-offs here, but for now I will leave this as is–we will
continue next week.</p>


  </div>

</article>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <!-- <h2 class="footer-heading">Kristopher Micinski</h2> -->

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Kristopher Micinski</li>
          <li><a href="mailto:kkmicins@syr.edu">kkmicins@syr.edu</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/kmicinski"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">kmicinski</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/krismicinski"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#fff" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">krismicinski</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Kris Micinski's Website. Love the lambda.
</p>
      </div>
    </div>

  </div>

</footer>

<script src="/bower_components/jquery/dist/jquery.min.js"></script>
<script src="/bower_components/jquery-ui/jquery-ui.min.js"></script>
<script src="/bower_components/bootstrap-sass/assets/javascripts/bootstrap.min.js"></script>


  </body>

</html>
