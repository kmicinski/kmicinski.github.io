<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kristopher Micinski</title>
    <description>Kris Micinski&apos;s Website. Love the lambda.
</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 01 Aug 2025 21:22:01 -0400</pubDate>
    <lastBuildDate>Fri, 01 Aug 2025 21:22:01 -0400</lastBuildDate>
    <generator>Jekyll v4.4.1</generator>
    
      <item>
        <title>Why Tail-Recursive Functions are Loops</title>
        <description>&lt;p&gt;One story every computing enthusiast should hear is the lesson of
how loops and tail-recursion are equivalent. We like recursive
functions because they’re amenable to induction, and we can derive
them in a way that is in direct correspondence with the definition of
the datatype over which they recur. We like loops because they’re
fast and make intuitive sense as long as variables don’t change in too
tricky a way.&lt;/p&gt;

&lt;p&gt;In general, recursive functions are slower than loops because they
push stack frames: the performance of most programs today is dominated
by memory reads/writes. The data we touch the most lives in the
cache–we do &lt;em&gt;not&lt;/em&gt; want to evict a ton of stuff from the cache, under
any circumstance. In a direct-style implementation of a recursive
function, the recursive call &lt;em&gt;has&lt;/em&gt; to push a stack frame to remember
what to do once the function returns:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; Racket
(define (sum l)
  (if (empty? l)
      0
      (+ (first l) (sum (rest l)))))

// C 
int sum(int *l, int length) {
    if (length == 0)
        return 0;
    else
        return l[0] + sum(l + 1, length - 1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When we get to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(+ (first l) (sum (rest l)))&lt;/code&gt;, we first call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(first
l)&lt;/code&gt; (which returns the first element). While we’re making that call,
we have to remember to come back and do &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(sum (rest l))&lt;/code&gt;–to be fully
precise, we remember that we need to do &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(rest l)&lt;/code&gt;, then take its
result &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; and call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(sum x)&lt;/code&gt;, remembering to come back and finally
take &lt;em&gt;that&lt;/em&gt; result and add it to the result of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(first l)&lt;/code&gt;. The reason
we have to do this is because we need to remember those partial
results (in this case the result of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(first l)&lt;/code&gt;): we have to store
them somewhere after all, and each time we make the recursive call, we
need to remember the result of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(first l)&lt;/code&gt; from &lt;em&gt;this&lt;/em&gt; call–we need
O(n) stack space for a list of size n.&lt;/p&gt;

&lt;p&gt;Of course, if we use iteration this all goes away:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; Racket
(define (sum l)
  (define x 0)
  (for ([elt l])
    (set! x (+ x elt)))
  x)

// C
int sum(const int *l, int length) {
    int x = 0;
    for (int i = 0; i &amp;lt; length; i++) {
        x += l[i];
    }
    return x;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We all have an intuitive sense of what the loop is doing: once we hit
the end of the loop, we do &lt;em&gt;not&lt;/em&gt; make a recursive call (we never issue
a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;call&lt;/code&gt; instruction in assembly), we simply &lt;em&gt;jump&lt;/em&gt; up to the
beginning of the loop. The key is that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; is being used as an
&lt;em&gt;accumulator&lt;/em&gt;, growing a partial result in a &lt;em&gt;bottom-up&lt;/em&gt; fashion as
the computation proceeds, eventually yielding the final value at the
end. Instead of keeping partial results on the stack, the loop takes a
&lt;em&gt;constant&lt;/em&gt; amount of space but linear time.&lt;/p&gt;

&lt;p&gt;In a tail-recursive implementation, the rule is that every recursive
call must be a &lt;em&gt;tail&lt;/em&gt; call. Intuitively, a tail call is a call which
is “immediately returned.” More formally, a subexpression of an
expression is in tail position if the return value from that
expression is the return value from the whole expression. For example,
in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(if guard e-t e-f)&lt;/code&gt;, both &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e-t&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e-f&lt;/code&gt; are in tail position,
but the guard is not: after we decide which branch to take, we’re
committed:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(define (foo ...)
  ...
  (if guard
    (f x y ...)
    (g z ...)))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once we finish executing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;guard&lt;/code&gt;, it would be &lt;em&gt;useless&lt;/em&gt; (but
&lt;strong&gt;correct&lt;/strong&gt;) to (a) push a stack frame, (b) wait on the result of the
subordinate call, and (c) merely return &lt;em&gt;that same result&lt;/em&gt;, because
all we’d be doing is &lt;em&gt;copying&lt;/em&gt; the return value from the callee and
propagating it back as the return value of the caller.  Being a tail
call is a syntactic property of a callsite: we (and the compiler) can
easily look at a piece of code and cheaply decide when a call is a
tail call versus not.&lt;/p&gt;

&lt;p&gt;This reasoning above generalizes to &lt;em&gt;any&lt;/em&gt; call expression in tail
position: &lt;em&gt;because a tail call will necessarily evaluate to its
result, administratively copying it up/down the stack is extensionally
a no-op&lt;/em&gt;. Now, the tail-recursive version uses a simple trick I teach
to all of my students: (a) identify an accumulator variable, (b)
instead of computing with the &lt;em&gt;result&lt;/em&gt; of the recursive call, compute
with the &lt;em&gt;current accumulator&lt;/em&gt;, (c) return the accumulator in the base
case:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; Racket
(define (sum l acc) ;; note: acc got added
  (if (empty? l)
      acc ;; this is the *true* return!
      (sum (rest l) (+ acc (first l)))))

// C -- we pass in length manually because we&apos;re using arrays
int sum(const int* l, int length, int acc) {
    if (length == 0) return acc;
    return sum(l + 1, length - 1, acc + l[0]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Both of these functions are tail recursive: because the only recursive
call to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum&lt;/code&gt; is &lt;em&gt;also&lt;/em&gt; the return value from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum&lt;/code&gt; (or, more
directly: because both calls to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum&lt;/code&gt; are in tail position). Since the
compiler knows that these are tail calls, a compiler with tail-call
optimization will ensure that both of these tail calls compile into
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jmp&lt;/code&gt; statements–with zero implication on stack usage–rather than
the more burdensome (on the cache, stack, etc.) direct-style
calls. Something that should concern you is this: if the function is
using constant stack space, how are the variables being updated /
represented!? The answer is that the arguments get &lt;strong&gt;stomped over&lt;/strong&gt;,
and &lt;strong&gt;mutably updated&lt;/strong&gt;, yielding the &lt;em&gt;exact same performance profile
as a loop!&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Now time for an exercise, what about this program, can you convert it
to using tail-recursion?&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; return a pair (cons cell) of the number of even numbers,
;; and the number of odd numbers.
;; HINT: use multiple accumulators. 
(define (even-odd l)
  (if (empty? l)
      (cons 0 0)
      (let ([v (even-odd (rest l))])
            (if (first l)
                (cons (add1 (car v)) (cdr v))
                (cons (car v) (add1 (cdr v))))))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What about &lt;em&gt;this&lt;/em&gt; program?&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; flattens a tree? into a list
;; It&apos;s hard because there are *two* calls to linearize--can you do anything?
(define (linearize t)
  (match t
    [&apos;empty &apos;()]
    [`(node ,v ,t0 ,t1) (append (list v) (linearize t0) (linearize t1))]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;One surprising fact is that we can systematically compile &lt;em&gt;any&lt;/em&gt;
program so that &lt;em&gt;every&lt;/em&gt; call is a tail-call, by completely
transforming the program into &lt;a href=&quot;https://matt.might.net/articles/cps-conversion/&quot;&gt;continuation-passing-style
(CPS)&lt;/a&gt;, this
essentially &lt;em&gt;eliminates&lt;/em&gt; the stack. Indeed, some compilers for
functional languages work precisely this way: those languages
&lt;strong&gt;cannot&lt;/strong&gt; fall prey to a stack overflow, because they have
essentially traded a monolithic (efficient, array-like) stack for a
deeply-nested stack, strewn throughout the heap—because the
continuations will be heap-allocated and nested. There are various
exciting trade-offs here, but for now I will leave this as is–we will
continue next week.&lt;/p&gt;

</description>
        <pubDate>Fri, 01 Aug 2025 00:00:00 -0400</pubDate>
        <link>/functional-programming/2025/08/01/loops/</link>
        <guid isPermaLink="true">/functional-programming/2025/08/01/loops/</guid>
        
        
        <category>functional-programming</category>
        
      </item>
    
      <item>
        <title>Modern Deduction Post 1: Chain-Forward Computation</title>
        <description>&lt;p&gt;Our setting is logic programming, a field which attempts to design
programming languages whose semantics have a close relationship to
formal logic. The reason we might want to do this is that it suits our
application domain more precisely than an implementation in a
traditional programming language. Thus, using a logic programming
language allows us to write more obviously-correct code, and perhaps
even code that can be extracted cleanly from a certified
implementation. Alternatively, if we did it ourselves, we’d have to do
what our compiler (interpreter, …) would do anyway, so there’s no
sense in doing it manually. Unfortunately, when we see a powerful
tool, we are tempted to use it for everything: if our application is
not ultimately-suited to the operationalization strategy of the logic
programming engine we’re using, we simply obfuscate the issue in a
veneer of formalism and end up with leaky abstractions. This is, I
speculate, why logic programming languages have never caught on
broadly for general-purpose programming. In this blog, I will detail
the various trade-offs and implementation paradigms for modern logic
programming engines, starting from Datalog and with a focus on program
analysis.&lt;/p&gt;

&lt;p&gt;The history of logic is rich, and I will not attempt to recount it
all. Here I will focus on more restricted, application-specific
languages, especially Datalog and its derivatives. The specific
features of these languages, and the particulars of their
implementation, often dovetail with a “right place, right time”
effect. For example, &lt;a href=&quot;https://suif.stanford.edu/papers/pldi04.pdf&quot;&gt;Datalog backed by
BDDs&lt;/a&gt; was a significant
step forward in terms of production program analyses. More modern
implementations eschew BDDs for more explicit representations, but it
remains the case that engineers and computer scientists are on the
lookout for logic-programming-based approaches to hard problems,
especially those which deal intrinsically in the enumeration of large
state spaces.&lt;/p&gt;

&lt;p&gt;Perhaps one of logic programming’s most exciting motivations is
program analysis. Program analysis systems automatically prove
properties about, find bugs in, or simply help us understand our
programs. These can come in a variety of forms from on-demand
in-editor type-checking to whole-program (runs in microseconds),
context-sensitive points-to analysis (days). Program analyses are
notoriously hard to specify, and are especially hard to implement in a
way that provides a close relationship to the formal
specification. Additionally, program analyses often grapple with large
state spaces in practice to solve interesting problems, and require
some amount of thought regarding high-performance implementation.&lt;/p&gt;

&lt;h4 id=&quot;chain-forward-computation-and-datalog&quot;&gt;Chain-Forward Computation and Datalog&lt;/h4&gt;

&lt;p&gt;The central evaluation mechanism in Datalog, and its derivatives, is
to saturate a set of rules (e.g., Horn clauses) to a fixed point, to
obtain a knowledge database in some domain. We call the computation
“chain forward” because the evaluation of such languages is guided by
an ordering on knowledge, typically set inclusion (in the case of
traditional Datalogs). In these settings, we define an “immediate
consequence” operator, which tells us everything which must be known,
as a consequence of what we currently know; crucially, this operator
is typically monotonic: we do not lose knowledge over time, though we
will discuss some interesting departures from this
assumption. Applying this immediate consequence operator repeatedly
yields a stream of knowledge databases over time. Assuming the
immediate consequence operator is monotone, this stream of knowledge
databases over time forms an ascending chain according to the ordering
on knowledge.&lt;/p&gt;

&lt;p&gt;Datalog’s syntax consisting of “facts” and “rules.” Facts are “known
statements” and always have the following form: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R(c0, ...)&lt;/code&gt;, where
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; is a relation name (identifier) and the arguments are
constants. For example &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt;(3,2)&lt;/code&gt; might be a fact, along with
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reaches(&quot;n0&quot;,&quot;n1&quot;)&lt;/code&gt;. But facts may not include variables, for
example: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reaches(&quot;n0&quot;,x)&lt;/code&gt; is disallowable as a fact, because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; is
not bounded in any way.&lt;/p&gt;

&lt;div class=&quot;language-scheme highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;relation?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;symbol?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;atom?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;symbol?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;;; atomic lits are symbols&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;;; variables must be explicitly tagged, not &apos;x, but &apos;(var x)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;var?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;symbol?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;var-or-atom?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;atom?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;var?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;;; tuples are untagged&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;tuple?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;f&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;atom?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;;; facts add a relation name (otherwise how would we know it)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;fact?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;f&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;relation?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;atom?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;;; notice that ∧ is implicit in the body&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;rule?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;relation?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;head-rel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;var-or-atom?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;lt;--&lt;/span&gt; 
       &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;relation?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;body-rels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;var-or-atom?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;no&quot;&gt;#t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let’s look at simplest interesting example: transitive closure. The
Datalog program (technically in Soufflé here) to implement transitive
closure &lt;a href=&quot;&quot;&gt;example (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tc.dl&lt;/code&gt;)&lt;/a&gt; is here (I elide some declarations):&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.output path
.decl edge(x:number,y:number)
.decl path(x:number,y:number)
edge(1,2). edge(2,3). edge(3,5). edge(5,4). edge(4,1). edge(4,8).
path(x, y) :- edge(x, y).
path(x, y) :- path(x, z), edge(z, y).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Running this program in Soufflé (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;souffle tc.dl&lt;/code&gt;) yields an output
database, the transitively-closed graph, in the file &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path.csv&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;datalog-cannot-search-disjunction-saturated-conjunctions-only&quot;&gt;Datalog cannot search (disjunction), saturated conjunctions only&lt;/h4&gt;

&lt;p&gt;Disjunctions in the head of a rule is disallowed: this is not
semantically within reach of Datalog. The following is invalid:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Q(x,...) ∨ R(x,...) ← P(...) ∧ R(...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once we have more than one positive literal in a clause, we need a SAT
solver. SAT solvers combine search (“guess new things”) and deduction
(“derive consequences”); Datalog solvers only employ deduction. Both
SAT and Datalog engines share some overlapping ideas; for example,
both use indexing, to accelerate joins (Datalog) and for efficient
unit propagation (SAT). But (&amp;gt;2)-SAT is strictly harder than Datalog:
2-SAT can be written as Horn clauses (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Q ← R&lt;/code&gt; is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;¬R ∨ Q&lt;/code&gt;), but 3-SAT
and beyond are out of reach. By contrast, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;∧&lt;/code&gt; in the head of a rule
presents no serious semantic issue: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Q(x,...) ∧ R(x,...) ← ...&lt;/code&gt; can
easily be desugared into two rules: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Q(x,...) ← ...&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R(x,...) ←
...&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;SAT solvers have an importance difference from Datalog solvers: they
forget information. This is important because, while you can use
Datalog to do SAT solving just fine, you will pay a massive
performance due to the concomitant over-materialization induced by
enumerating all possibilities: you would be &lt;em&gt;literally materializing
O(2ⁿ)&lt;/em&gt;. Of course, there are languages that embrace such
cartoonishly-huge state spaces by design (answer-set programming, for
example), and their designs are subsequently guided around these
issues; indeed, grounding on-the-fly is an active research topic
within ASP.&lt;/p&gt;

&lt;p&gt;As an example, think about how you could write 5-clique:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clique3(A, B, C) :-
    edge(A, B), edge(A, C), edge(B, C),
    A != B, A != C, B != C.
clique4(A, B, C, D) :-
    clique3(A, B, C),
    edge(A, D), edge(B, D), edge(C, D),
    A != D, B != D, C != D.
clique5(A, B, C, D, E) :-
    clique4(A, B, C, D),
    edge(A, E), edge(B, E), edge(C, E), edge(D, E),
    A != E, B != E, C != E, D != E.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;semi-naïve-evaluation&quot;&gt;Semi-Naïve Evaluation&lt;/h4&gt;

&lt;p&gt;One issue with the repeated application of the rules is that if we use
an explicit set-based representation of tuples, each iteration we’ll
“rediscover” all knowledge from every previous iteration—this
translates to additional data load, without commensurate knowledge
throughput. In Datalog, the solution is to employ a compilation into
an incrementalized IR, ala semi-naïve evaluation. For example, the
recursive rule in transitive closure becomes:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;path(x,z) ← path(x,y) ∧ edge(y,z)
          | 
   becomes| No Δ versions for edge as it is static
          |
Δpath(x,z) ← (Δpath(x,y) ∧ edge(y,z)) - path
i.e., 
Δpath(x,z) ∪= (Δpath(x,y) ⋈ edge(y,z)) - path
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The rule expands into a single rule, because the relation &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;edge&lt;/code&gt; never
changes–thus, tracking a delta version would be
irrelevant. Additionally, we assume that at the end of each iteration,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Δpath&lt;/code&gt; is merged into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path&lt;/code&gt;. In the more general case such as:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;g(y,x) ∧ p(x,z) ← p(x,y) ∧ g(y,z)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We would need to split the rule into several versions: one to join
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Δp&lt;/code&gt; with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g&lt;/code&gt;, one to join &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt; with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Δg&lt;/code&gt;, and one to join &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Δp&lt;/code&gt; with
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Δg&lt;/code&gt;. Think about what would happen if we have only &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Δp ⋈ Δg&lt;/code&gt;: if we
have facts &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(x,y)&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Δp&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(y,z)&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Δg&lt;/code&gt;, everything works
fine. But what happens if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(x,y)&lt;/code&gt; skips an iteration? It would be hard
to ensure that doesn’t happen (though some work certainly explores
this to a degree), and so we diversify our rules to enable us to catch
things in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Δp&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Δg&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Previously, I mentioned the resulting rule would look something like:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Δpath(x,z) ∪= (Δpath(x,y) ⋈ edge(y,z)) - path
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In fact, all rules within a fixedpoint (more specifically, an SCC of
rules) will have the structure:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ΔR(x...) ∪= (ΔR(x,...) ⋈ Q(y,...)) - R
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There is a crucial tacit point to be explained here: deduplication,
i.e., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;- R&lt;/code&gt; is dirt cheap when implemented thoughtfully, and it is
possible to parallelize nicely. There is no explicit scan of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; in
implementing subtraction, rather every rule generates a set of
possibly-new tuples, which are deduplicated in some efficient manner
to add to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ΔR&lt;/code&gt; at the end of each iteration, before emptying &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ΔR&lt;/code&gt; in
preparation for the next iteration.&lt;/p&gt;

&lt;p&gt;I will not code up semi-naïve evaluation here, but will likely discuss
a general approach to forward differentation and incrementalization in
subsequent posts.&lt;/p&gt;

&lt;h4 id=&quot;relational-algebra&quot;&gt;Relational Algebra&lt;/h4&gt;

&lt;p&gt;The explicit focus on bound variables has made the above presentation
informal, as substitution was never defined. Indeed, substitution is
“where computation happens” here in much the same way as in the
λ-calculus. However, handling binders is a bit tedious, and it turns
out there is a better, more systematic way. In the same way that
category theory will avoid mentioning concrete points for products A ×
B, relational algebra will avoid mentioning explicitly-named points
for manipulating relations.&lt;/p&gt;

&lt;p&gt;The lack of explicit binders allows us to write an obviously-correct
(albeit slow) interpreter for a conjunctive query that produces sets
of tuples as its output:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; q: query?
;; db: hashmap from relation name ↦ ℘(Tuple)
;; returns a set of tuples
(define (interpret-query q db)
  (match q
    [`(literal-tuple ,es ...) (set es)]
    [`(scan ,R) (hash-ref db R)]
    [`(select from ,q+ where column ,n equals ,k)
     (list-&amp;gt;set (filter (lambda (x) (equal? (list-ref x n) k))
                        (set-&amp;gt;list (interpret-query q+ db))))]
    [`(,q0 ∪ ,q1) (set-union (interpret-query q0 db)
                             (interpret-query q1 db))]
    [`(,q0 ∩ ,q1) (set-intersect (interpret-query q0 db)
                                 (interpret-query q1 db))]
    [`(reorder ,q ,order ...)
     (let ([ts (set-&amp;gt;list (interpret-query q db))])
       (set-&amp;gt;list
        (map (λ (t) (map (λ (i) (list-ref t i)) order))
             ts)))]
    [`(project ,q to first ,n)
     (list-&amp;gt;set (map (λ (t) (take t n)) (set-&amp;gt;list (interpret-query q db))))]
    [`(,q0 ⋈ ,q1 on first ,N)
     (list-&amp;gt;set
      (foldl
       (λ (t0 tups)
         (foldl (λ (t1 tups)
                  (if (equal? (take t0 N) (take t1 N))
                      (set-add tups (append (take t0 N) (drop t0 N) (drop t1 N)))
                      tups))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The implementation is mostly standard: notice that ⋈ degenerates to
the cartesian product in the case that N=0 (since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(take t 0)&lt;/code&gt; returns
the empty list for all &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;). We include only binary joins, k-ary joins
are typically decomposed into chains or trees of binary joins: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R ⋈ Q
⋈ S&lt;/code&gt; can be construed as either &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(R ⋈ Q) ⋈ S&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R ⋈ (Q ⋈ S)&lt;/code&gt; (3 or
more joins would allow us to consider trees, too). Unfortunately, the
wrong choice could force the enumeration to explode: if a subordinate
join produces lots of junk which is later filtered out by the outer
join, we may end up doing more work than an alternative join
plan. Join planning–-the process of optimally deciding on a join
decomposition–is a challenging aspect of the implementation; for some
programs, &lt;em&gt;any&lt;/em&gt; particular static join plan is be inefficient, as
relation sizes dynamically evolve, the optimal join plan may shift as
well. While traditional databases put a lot of effort into query
planning, Datalog has taken a slightly different approach, with only
scant recent work exploring dynamic plans.&lt;/p&gt;

&lt;p&gt;With this implementation, we can write query to find us all of the
one-hop transitive edges: the query we want is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;edge(x,y), path(y,z)&lt;/code&gt;,
which operationalizes to a join between edge and path; since we want
to line up the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y&lt;/code&gt;s we reorder &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;edge&lt;/code&gt;, then reorder the join result
(to gather &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;z&lt;/code&gt;), then project the first two elements.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(interpret-query
 &apos;(project (reorder ((reorder (scan edge) 1 0) ⋈ (scan path) on first 1) 1 2 0)
           to first 2)
 (hash &apos;edge (set &apos;(a b) &apos;(b c) &apos;(c d) &apos;(b e))
       &apos;path (set &apos;(a b) &apos;(b c) &apos;(c d) &apos;(b e))))
;; yields (set &apos;(a e) &apos;(b d) &apos;(a c))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Assuming we’re willing to write programs in terms of relational
algebra, we can iteratively generate new tuples. An &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RA-rule?&lt;/code&gt; extends
a specific relation (recall we’re taking a point-free style) with the
result of a query. We can interpret rules by evaluating the query and
unioning the result set into the necessary relation. A program is a
set of rules, which we can evaluate by iteratively (to a fixed point)
applying all rules until we see no changes in the database.&lt;/p&gt;

&lt;div class=&quot;language-scheme highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;RA-rule?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;relation?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∪&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;RA-query?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-rule&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;match-define&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;,R&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∪&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hash-set&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set-union&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hash-ref&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-query&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-program&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;next-iteration&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;foldl&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-rule&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;do-some-more&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;equal?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;next-iteration&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;do-some-more&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;next-iteration&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;do-some-more&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we can write small programs:&lt;/p&gt;

&lt;div class=&quot;language-scheme highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-program&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;edge&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∪&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;literal-tuple&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;edge&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∪&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;literal-tuple&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;edge&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∪&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;literal-tuple&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∪&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∪&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;project&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;reorder&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;reorder&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⋈&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                     &lt;span class=&quot;nv&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next time, we’ll plan to talk a bit about how to systematically
compile our high-level rules into the RA plans, and discuss the
various trade-offs in doing so.&lt;/p&gt;

&lt;h4 id=&quot;the-full-code&quot;&gt;The full code&lt;/h4&gt;

&lt;p&gt;Is here in &lt;a href=&quot;https://gist.github.com/kmicinski/e31ef6f2526c21cb0ec968f0e260e4a0&quot;&gt;this gist&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-scheme highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;;; Relational algebra&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;lang&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;racket&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;relation?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;symbol?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;atom?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;symbol?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;;; atomic lits are symbols&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;;; variables must be explicitly tagged, not &apos;x, but &apos;(var x)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;var?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;symbol?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;var-or-atom?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;atom?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;var?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;;; tuples are untagged&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;tuple?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;f&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;atom?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;;; facts add a relation name (otherwise how would we know it)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;fact?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;f&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;relation?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;atom?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;;; notice that ∧ is implicit in the body&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;rule?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;relation?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;head-rel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;var-or-atom?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;lt;--&lt;/span&gt; 
       &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;relation?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;body-rels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;var-or-atom?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;no&quot;&gt;#t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;;; should all be true&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;rule?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;lt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;rule?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;lt;--&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;rule?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;lt;--&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;edge&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;rule?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&amp;lt;--&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;edge&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;;; RA queries&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;RA-query?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;literal-tuple&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;atom?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;es&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;;; scan a relation&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;relation?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;RA-query?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
              &lt;span class=&quot;nv&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;column&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;nonnegative-integer?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
              &lt;span class=&quot;nv&quot;&gt;equals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;atom?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
     &lt;span class=&quot;no&quot;&gt;#t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;;; natural join on the first N columns, values must be equal&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;RA-query?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⋈&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;RA-query?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;nonnegative-integer?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;RA-query?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∪&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;RA-query?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;RA-query?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∩&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;RA-query?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;;; reorder tuples&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;reorder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;RA-query?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;nonnegative-integer?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;;; project the first n elements of tuples&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;project&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;RA-query?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;nonnegative-integer?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;;; need closed-world assumption&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;RA-query?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;;; q: query?&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;;; db: hashmap from relation name ↦ ℘(Tuple)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;;; returns a set of tuples&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-query&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;literal-tuple&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;es&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;es&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hash-ref&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;q+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;column&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;equals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;list-&amp;gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;equal?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list-ref&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set-&amp;gt;list&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-query&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q+&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;,q0&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∪&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;q1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set-union&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-query&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q0&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                             &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-query&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;,q0&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∩&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;q1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set-intersect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-query&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q0&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                                 &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-query&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;reorder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set-&amp;gt;list&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-query&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))])&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set-&amp;gt;list&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;list-ref&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
             &lt;span class=&quot;nv&quot;&gt;ts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;project&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;list-&amp;gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set-&amp;gt;list&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-query&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;,q0&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⋈&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;q1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;list-&amp;gt;set&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;foldl&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;t0&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tups&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;foldl&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tups&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;equal?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t0&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set-add&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;tups&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;append&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;take&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t0&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;drop&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t0&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;drop&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
                      &lt;span class=&quot;nv&quot;&gt;tups&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;nv&quot;&gt;tups&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set-&amp;gt;list&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-query&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q1&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set-&amp;gt;list&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-query&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q0&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))]))&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;RA-rule?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;relation?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∪&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;RA-query?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;#f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-rule&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;match-define&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;,R&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∪&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hash-set&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set-union&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hash-ref&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-query&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-program&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;next-iteration&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;foldl&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-rule&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;do-some-more&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;equal?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;next-iteration&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;do-some-more&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;next-iteration&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;do-some-more&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;;; relations: hash from relation names to their associated arities&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;;; herbrand-base is a list of atoms &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;herbrand-universe&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;relations&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;herbrand-base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;;; generate a cartesian product of arity n with atoms from herbrand-base&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(())&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;append&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cons&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;herbrand-base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))))&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;foldl&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hash-set&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hash-ref&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;relations&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hash-keys&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;relations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-query&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;project&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;reorder&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;reorder&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⋈&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;nv&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;&apos;edge&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
       &lt;span class=&quot;ss&quot;&gt;&apos;path&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;interpret-program&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;edge&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∪&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;literal-tuple&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;edge&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∪&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;literal-tuple&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;edge&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∪&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;literal-tuple&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∪&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;∪&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;project&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;reorder&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;reorder&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⋈&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                     &lt;span class=&quot;nv&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sat, 11 May 2024 00:00:00 -0400</pubDate>
        <link>/modern-deduction/1</link>
        <guid isPermaLink="true">/modern-deduction/1</guid>
        
        
      </item>
    
      <item>
        <title>Modern Deduction Post 0: Prologue</title>
        <description>&lt;p&gt;Over the past few years, my collaborators and I have been exploring
the design of high-performance logic programming engines for a wide
variety of tasks, including program analysis (points-to analysis,
abstract interpretation), graph analytics (transitive closure,
PageRank), and security (binary code similarity, disassembly, and
decompilation). We (myself, my collaborators, and our students) have
engineered a variety of systems aiming for both (a) state-of-the-art
performance at the highest scale (shared-memory parallelism,
distribution via MPI, SIMD on GPUs, and GPU cluster computing) and (b)
semantic extensions (monotonic aggregation, algebraic data) to
Datalog.&lt;/p&gt;

&lt;p&gt;I will be chronicling our efforts (mostly the relevant background) in
this series of posts, Modern Deduction. I will plan to put out a post
once every month or two.&lt;/p&gt;

&lt;p&gt;Posts:&lt;/p&gt;

</description>
        <pubDate>Fri, 05 Apr 2024 00:00:00 -0400</pubDate>
        <link>/modern-deduction/0</link>
        <guid isPermaLink="true">/modern-deduction/0</guid>
        
        
      </item>
    
      <item>
        <title>Mid-Point Review Materials</title>
        <description>&lt;p&gt;This page holds my “year 3 review” materials for evaluation and
promotion at Syracuse University.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://kmicinski.com/assets/personal.pdf&quot;&gt;My detailed personal statement (including teaching and research statements) is here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://kmicinski.com/assets/cv.pdf&quot;&gt;My current CV is linked here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A (~22MB) zip file linked
&lt;a href=&quot;https://kmicinski.com/assets/year-3-review.zip&quot;&gt;here&lt;/a&gt; gives the full
review packet, including CV, papers, and my personal statement.&lt;/p&gt;
</description>
        <pubDate>Fri, 16 Dec 2022 00:00:00 -0500</pubDate>
        <link>/year-3-review</link>
        <guid isPermaLink="true">/year-3-review</guid>
        
        
      </item>
    
      <item>
        <title>Certifying Interpreters in Racket</title>
        <description>&lt;p&gt;When I began programming, I read a copy of Richard Steven’s “Programming in the UNIX Environment.” Ultimately, my early experimentations with C were a failure; however, I later read David Beazley’s “Python: Essential Reference,” and was quickly able to pick up the UNIX API via it’s much simpler (admittedly, largely due to Beazley’s writing) Python counterpart. After teaching my undergraduate PL courses in Scheme variants these past few years I have wondered if we can understand type theory’s operationalization (via proof objects) using a similar shift in perspective.&lt;/p&gt;

&lt;p&gt;Here, I rigorously define an interpreter which produces a certificate
of its own correctness—assuming you trust the correctness of our
metalanguage, which (in the interests of appeasing the more skeptical
among us) we treat as S-expression comparison. Here I use Racket, but
any similar dynamic language with matching (or, if in OO, virtual
methods) would work to illustrate the key ideas. I do use Racket’s
contracts to check certificates, though other implementations could
defer this to the end or even elide checking entirely.&lt;/p&gt;

&lt;h3 id=&quot;the-language&quot;&gt;The Language&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; Specification of IfArith&apos;s syntax as a Racket predicate
(define (expr? e)
  (match e
    [(? nonnegative-integer? n) #t]
    [(? symbol? x) #t]
    [`(let ,(? symbol? x) ,(? expr? e) ,(? expr? e-body))]
    [`(plus ,(? expr? e0) ,(? expr? e1)) #t]
    [`(not ,(? expr? e-guard)) #t]
    [`(if0 ,(? expr? e0) ,(? expr? e1) ,(? expr? e2)) #t]
    [_ #f]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(define e0 &apos;(plus 2 1)) ;; 3
(define e1 &apos;(plus 1 (if0 0 1 2))) ;; 2
(define e2 &apos;(let x (plus 0 0) (plus x 1))) ;; 1 
(define e3 &apos;(let x (plus 0 (if0 (plus 0 0) 1 0)) (plus x 0))) ;; 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;the-proofs&quot;&gt;The Proofs&lt;/h3&gt;

&lt;p&gt;Now the tricky part: we need to think about what proofs for evaluation
of terms in our little language look like. To be precise about it, we
need to define a relation: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e, ρ ⇓ v&lt;/code&gt;, such that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt; is an expression,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ρ&lt;/code&gt; is an environment (mapping variables to values) and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v&lt;/code&gt; is a
value. To be constructive about it, we need to algebraically define a
structure representing proofs that the evaluation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ρ&lt;/code&gt;
evaluates to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v&lt;/code&gt;. Following the Scheme tradition of homoiconicity, we
represent proofs as S-expressions themselves; inference rules using
pattern matching over these S-expressions to mirror the natural
deduction (big-step) style in which we would write our semantics on
paper. As an example, here’s a derivation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(if0 0 (plus 1 1) 0)&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(⇓-if-true
  (⇓-const ----- 
         (0 ∅ ⇓ O))
  (⇓-plus
   (⇓-const -----
        (1 ∅ ⇓ (S O)))
   (⇓-const -----
          (1 ∅ ⇓ (S O)))
   (plus -----
      (= (+ (S O) (S O)) (S (S O))))
   -----
   ((plus 1 1) ∅ ⇓ (S (S O))))
  -----
  ((if0 0 (plus 1 1) 0) ∅ ⇓ (S (S O))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Racket’s pattern matcher is, of course, very different than a more
elaborate matcher centered around higher-order unification in a
statically-typed setting. Manually explicating the unification becomes
a bit of a chore after a while; certainly a rebuke to the thought of
using this as a serious strategy for type theory, but at the same time
precisely the reason we’re doing it this way.&lt;/p&gt;

&lt;p&gt;Of course it would be possible (especially in such a simple semantics
as this) to define &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e, ρ ⇓ v&lt;/code&gt; using substitution to implement
variables; I explicitly materialize environments to (a) anticipate
closures (later) and (b) present a representational challenge upon
which I would like to expand a bit. Of course, using Racket as our
metalanguage, we could simply use hashes for environments. But
remember—we are trying to appease the pedants among us, thus
representation must be as symbolic as possible. Similarly, I represent
the naturals symbolically. I do allow myself a serious concession: I
internalize &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plus&lt;/code&gt;, as I elide &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fix&lt;/code&gt; in the source language. If this
disappoints you, I would say there’s no fundamental barrier; we could
easily-enough (via environments) implement application and then a
fixed-point combinator.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; naturals
(define (nat? n)
  (match n [&apos;O #t] [`(S ,(? nat? n)) #t] [_ #f]))

(define/contract (num-&amp;gt;nat n)
  (-&amp;gt; nonnegative-integer? nat?)
  (match n
    [0 &apos;O]
    [n `(S ,(num-&amp;gt;nat (- n 1)))]))

(define/contract (nat-&amp;gt;num n)
  (-&amp;gt; nat? nonnegative-integer?)
  (match n
    [&apos;O 0]
    [`(S ,x) (add1 (nat-&amp;gt;num x))]))

(define/contract (nat-add s0 s1)
  (-&amp;gt; nat? nat? nat?)
  (match s0
    [&apos;O s1]
    [`(S ,s0+) `(S ,(nat-add s0+ s1))]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To represent environments we define (a) a predicate dictating valid
structure for environments and (b) a predicate, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(env-maps? ρ x v
pf)&lt;/code&gt;, which defines the structure of valid proofs showing that
environment &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ρ&lt;/code&gt; maps variable &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; to value &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v&lt;/code&gt;. Both of these are in
the de-facto “trusted computing base,” in the sense that if your
definition of proofs is broken (i.e., don’t faithfully capture what
you want to prove) then it doesn’t matter that your interpreter
produces proofs. And, of course, this is the biggest drawback of using
an untyped language to do this—we only get some rough syntactic
checking, similar to tools such as Ott but not dependently-typed
languages or provers. To avoid completely defeating the purpose of our
exercise here, I have followed a bit of a trick to rely minimally on
Racket as a metatheory: because many objects internal to the semantics
(e.g., numbers, environments, and proofs) are represented purely
symbolically (as S-expressions), we primarily rely upon Racket for
S-expression equality and dispatch (matching). Aside from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plus&lt;/code&gt; our
semantics uses a very small subset of Racket: I believe essentially
either (equivalently) existential fixed-point logic (of a Herbrand
base comprising S-expressions) or constrained horn clauses (whose
background logic includes S-expression equality and
structurally-recursive addition).&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; environments
(define (environment? ρ)
  (match ρ
    [&apos;∅ #t]
    [`(↦ ,(? environment? ρ+) ,(? symbol? x) ,(? value? v)) #t]
    [_ #f]))

;; environment lookup -- predicate (inductive defn.)
(define/contract (env-maps? pf ρ x v)
  (-&amp;gt; any/c environment? symbol? value? boolean?)
  (match pf
    [`(↦-hit
       ------
       (↦ ,ρ ,x0 ,v0))
     (and (equal? x0 x) (equal? v0 v))]
    [`(↦-miss
       ,next-pf
       -----
       (↦ ,ρ ,x0 ,_))
     (and (not (equal? x0 x))
          (env-maps? next-pf ρ x v))]
    [_ #f]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The implementation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(⇓ pf e ρ v)&lt;/code&gt; follows its natural deduction
counterpart (which I have not written down, but try to stylize via my
spacing). Our procedure checks the proof, recursively calling itself
to check subproofs—mirroring the top-down process you may follow on
a whiteboard to check the proof yourself, though Reynolds points out
that the order of sub-checks is inherited from the metalanguage (i.e.,
Racket’s control flow).&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; proofs of evaluation
(define/contract (⇓ pf e ρ v)
  (-&amp;gt; any/c expr? environment? value? boolean?)
  (match pf
    ;; Const
    [`(⇓-const
       -----
       (,(? nonnegative-integer? n) ,ρ+ ⇓ ,v+))
     (and (equal? (num-&amp;gt;nat n) v) (equal? v v+) (equal? ρ+ ρ))]
   ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Checking proofs for constants is easy. The rest of the rules follow
their natural deduction counterparts; the tedious part is the
administrative overhead required to implement the store-passing
construction. Of course my code is a bit smelly here; the ad-hoc use
of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;consequent&lt;/code&gt; points to a much cleaner refactoring that elides using
pairs of a return value and its proof in favor of projecting the value
from the proof, but the point here is to stick to what I think I’d end
up with doing it in an interactive proof assistant.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    ;; Var
    [`(⇓-var ,proof-x-in-ρ
       -----
       (,(? symbol? x) ,(? environment? ρ+) ⇓ ,(? value? v+)))
    (and (equal? ρ+ ρ) (equal? v+ v) (env-maps? proof-x-in-ρ ρ x v))]
    ;; Let
    [`(⇓-let
       ,proof-e0
       ,proof-e1
       -----
       ((let ,x ,e0 ,e1) ,(? environment? ρ+) ⇓ ,(? value? v+)))
     (and (equal? v+ v) (equal? ρ+ ρ)
          (⇓ proof-e0 e0 ρ (last (consequent proof-e0)))
          (⇓ proof-e1 e1 `(↦ ,ρ ,x ,(last (consequent proof-e0)))
		                            (last (consequent proof-e1))))]
    ;; Plus
    [`(⇓-plus
       ,proof-e0
       ,proof-e1
       (plus ----- (= (+ ,v0+ ,v1+) ,v-r))
       -----
       ((plus ,e0 ,e1) ,ρ+ ⇓ ,v-r))
     #:when (and (equal? v-r v) (equal? ρ+ ρ))
     (define v0 (last (consequent proof-e0)))
     (define v1 (last (consequent proof-e1)))
     (and (⇓ proof-e0 e0 ρ v0)
          (⇓ proof-e1 e1 ρ v1)
          (equal? v0+ v0)
          (equal? v1+ v1)
          (equal? v-r (nat-add v0 v1)))]
    ;; Not
    [`(⇓-not-0
       ,proof-e0
       -----
       ((not ,e0) ,ρ ⇓ O))
     (define v0+ (match (consequent proof-e0) [`(,_ ,_ ⇓ ,v) v]))
     (and (equal? v0+ v) (not (equal? v &apos;O)) (⇓ proof-e0 e0 ρ v))]
    [`(⇓-not-1
       ,proof-e0
       -----
       ((not ,e0) ,ρ ⇓ (S O)))
     (define v0+ (match (consequent proof-e0) [`(,_ ,_ ⇓ ,v) v]))
     (and (equal? v0+ v) (equal? v &apos;O) (⇓ proof-e0 e0 ρ v))]
    ;; If-True
    [`(⇓-if-true
       ,proof-guard-true
       ,proof-e1-v-res
       -----
       ((if0 ,e0 ,e1 ,e2) ,ρ ⇓ ,v))
     (match (consequent proof-guard-true)
       [`(,_ ,_ ⇓ O)
        (and (⇓ proof-guard-true e0 ρ &apos;O)
             (⇓ proof-e1-v-res e1 ρ v))])]
    ;; If-False
    [`(⇓-if-false
       ,proof-guard-false
       ,proof-e1-v-res
       -----
       ((if0 ,e0 ,e1 ,e2) ,ρ ⇓ ,v+))
     #:when (equal? v+ v)
     (match (consequent proof-guard-false)
       [`(,_ ,_ ⇓ ,n)
        (and (not (equal? n &apos;O))
             (⇓ proof-guard-false e0 ρ n)
             (⇓ proof-e1-v-res e1 ρ v))])]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;the-programs&quot;&gt;The Programs&lt;/h3&gt;

&lt;p&gt;Compared to the checking, writing the proofs is surprisingly
straightforward—even pleasant (okay; maybe not pleasant). A common
idiom when writing certified (proof-backed) code is the notion of
returning an existential, i.e., a witness alongside its proof. Of
course, the key challenge in writing certified code is convincing
yourself of its correctness.  There are a variety of ways you could do
this: you could inspect the output of the evaluator I write and ensure
that they match the specification, for example. However, for full
clarity, I will use Racket’s contract system, which allows dynamic
checking—this allows us to check the correctness of our evaluators
as we go, but of course won’t prove correctness across all runs, and
using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;define/contract&lt;/code&gt; also interposes the check at &lt;em&gt;every&lt;/em&gt; callsite
(a serious overhead), though I am sure you can use your imagination
about how this could be made faster.&lt;/p&gt;

&lt;p&gt;Let’s start with environments, writing a function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(lookup ρ x)&lt;/code&gt;,
which returns a proof that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; returns some value &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v&lt;/code&gt;–if it doesn’t,
we would just throw a dynamic error due to a match failure–we are
posting a proof exists. We can write a contract to ensure that the
code we use to do this is correct. Racket’s default arrow contract
combinator, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt;, is not powerful enough to express dependent
contracts, where a property of the result depends on one of the
inputs. However, Racket’s more powerful &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&amp;gt;i&lt;/code&gt; does allow dependent
contracts, allowing us to write a version of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lookup&lt;/code&gt; which both
computes what we want and checks to ensure its correctness:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; decision procedure for lookup -- returns witness and proof of inclusion
(define/contract (lookup ρ x)
        ;; v---- domain ----v
    (-&amp;gt;i ([ρ environment?] [x symbol?])
        ;; range -- produces a proof dependent on ρ,x
         [result (ρ x)
                 (match-lambda [`(,(? value? v) . ,pf) (env-maps? pf ρ x v)]
                               [_ #f])])
  (match ρ
    [`(↦ ,ρ1 ,x1 ,v) #:when (equal? x1 x)
                     `(,v . (↦-hit ------ (↦ ,ρ ,x ,v)))]
    [`(↦ ,ρ1 ,x1 ,v) #:when (not (equal? x1 x))
                     (match (lookup ρ1 x)
                       [`(,v . ,pf)
                        `(,v . (↦-miss ,pf ----- (↦ ,ρ1 ,x1 ,v)))])]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Finally, the interpreter itself—unadorned by the ceremony and
pedantics of low-level unification checking—is surprisingly
unintimidating and to-the-point.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; produce a value alongside a proof of its correctness
(define/contract (eval e ρ)
  ;; contract: returns pair of value and proof of its derivation
  (-&amp;gt;i ([e expr?] [ρ environment?])
       [result (e ρ)
               (lambda (witness-pf) (match witness-pf
                                      [`(,(? value? v) . ,pf) (⇓ pf e ρ v)]
                                      [_ #f]))])
  (match e
    [(? nonnegative-integer? n)
     (cons (num-&amp;gt;nat n)
           `(⇓-const
             -----
             (,n ,ρ ⇓ ,(num-&amp;gt;nat n))))]
    [(? symbol? x)
     (match (lookup ρ x)
       [`(,v . ,pf)
        (cons v `(⇓-var
                  ,pf
                  -----
                  (,x ,ρ ⇓ ,v)))])]
    [`(let ,x ,e ,eb)
     (match (eval e ρ)
       [`(,v . ,pf-e)
        (match (eval eb `(↦ ,ρ ,x ,v))
          [`(,v-res . ,pf-v)
           (cons v-res
                 `(⇓-let
                   ,pf-e
                   ,pf-v
                   -----
                   ((let ,x ,e ,eb) ,ρ ⇓ ,v-res)))])])]
    [`(plus ,e0 ,e1)
     (match-define `(,v0 . ,pf-v0) (eval e0 ρ))
     (match-define `(,v1 . ,pf-v1) (eval e1 ρ))
     (define v-res (nat-add v0 v1))
     (cons v-res
           `(⇓-plus
             ,pf-v0
             ,pf-v1
             (plus ----- (= (+ ,v0 ,v1) ,v-res))
             -----
             ((plus ,e0 ,e1) ,ρ ⇓ ,v-res)))]
    [`(not ,e)
     (match (eval e ρ)
       [`(0 . ,pf-e)
        (cons &apos;(S O)
              `(⇓-not-1
                ,pf-e
                -----
                ((not ,e) ρ ⇓ (S O))))]
       [`(,v0 . ,pf-e)
        (cons &apos;O
              `(⇓-not-0
                ,pf-e
                -----
                ((not ,e) ρ ⇓ O)))])]
    [`(if0 ,e0 ,e1 ,e2)
     (match (eval e0 ρ)
       [`(O . ,pf-e0)
        (match (eval e1 ρ)
          [`(,v . ,pf-v)
           (cons v
                 `(⇓-if-true
                   ,pf-e0
                   ,pf-v
                   -----
                   ((if0 ,e0 ,e1 ,e2) ,ρ ⇓ ,v)))])]
       [`(,n . ,pf-e0)
        (match (eval e2 ρ)
          [`(,v . ,pf-v)
           (cons v
                 `(⇓-if-false
                   ,pf-e0
                   ,pf-v
                   -----
                   ((if0 ,e0 ,e1 ,e2) ,ρ ⇓ ,v)))])])]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;visualizing-our-proofs&quot;&gt;Visualizing our Proofs&lt;/h3&gt;

&lt;p&gt;Alright, so now our interpreter writes proofs–what do they look like?
Thankfully, we used S-expressions.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; nice latex; comment out the labels by adding a % before \\tiny
(define (pf-&amp;gt;tex pf)
  (define name (first pf))
  (define antecedents (reverse (list-tail (reverse (list-tail (cdr pf) 0)) 2)))
  (foldr
   (lambda (k v acc) (string-replace acc k v))
   (format &quot; \n \\frac{ ~a }{ \\texttt{ ~a } }}&quot;
           name
           (string-join (map pf-&amp;gt;tex antecedents) &quot;\\,&quot;)
           (consequent pf))
   &apos;(&quot;⇓&quot; &quot;∅&quot; &quot;↦&quot;)
   &apos;(&quot;\\ensuremath{\\Downarrow}&quot; &quot;\\ensuremath{\\emptyset}&quot; 
     &quot;\\ensuremath{\\mapsto}&quot;)))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here’s the complete derivation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;((plus 1 (if0 0 1 2)))&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/plus-1.png&quot; alt=&quot;Proof of ((plus 1 (if0 0 1 2)))&quot; style=&quot;width:650px&quot; class=&quot;post-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And a longer program where I had to remove the rule names in
rendering…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/longproof.png&quot; alt=&quot;Longer proof&quot; style=&quot;width:650px&quot; class=&quot;post-image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;metatheoretic-concessions-for-the-working-programmer&quot;&gt;Metatheoretic Concessions for the Working Programmer&lt;/h3&gt;

&lt;p&gt;Obviously we would never write an interpreter in Racket the way we did
above: there’s too much extraneous math (i.e., the proof objects). I
think it’s surprising, though, to see how much more direct the code
becomes by (a) erasing the proofs, (b) implementing the environment as
hashes, and (c) relying upon racket’s built-in representation of
numbers. The biggest burden in my implementation is obviously (a), as
I have explicated the proofs via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cons&lt;/code&gt;. Tighter implementations exist
that would hide the ugliness via (say) monads. Eliminating proofs also
eliminates a lot of administrative matching and in some places allows
to make tail calls to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eval&lt;/code&gt; where we couldn’t before, giving us a
textbook metacircular interpreter. I think it is interesting to see
just how directly a translation it is: I systematically removed each
feature (in the same way an extractor would) to achieve the simpler
implementation.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(define (eval-simpl e ρ)
  (match e
    [(? nonnegative-integer? n) n]
    [(? symbol? x) (hash-ref ρ x)]
    [`(let ,x ,e ,eb) (eval-simpl eb (hash-set ρ x (eval-simpl e ρ)))]
    [`(plus ,e0 ,e1) (+ (eval-simpl e0 ρ) (eval-simpl e1 ρ))]
    [`(not ,e)
     (match (eval-simpl e ρ)
       [0 1]
       [_ 0])]
    [`(if0 ,e0 ,e1 ,e2)
     (match (eval-simpl e0 ρ)
       [0 (eval-simpl e1 ρ)]
       [_ (eval-simpl e2 ρ)])]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Do I think this is the future of dependently typed programming? Of
anything? Perhaps both no. Racket is not a particularly appealing
implementation language for type theory and its pattern matching is
not designed to scale to settings where higher-order unification is of
concern to the user. Similarly, this code has serious algorithmic
inefficiencies; plenty of the proof checking could be memoized, and
perhaps some simple contract trick would achieve this (though other
evaluation strategies could, e.g., use tabling in the metatheory). I
largely wrote this up to motivate my thoughts on (the potential of)
explaining the operationalization of proof objects to students as an
extension of operational semantics in the untyped setting I teach in
my class. Perhaps this will help someone draw connections between
operational semantics and proof objects, though I hesitate to say type
theory, broadly.&lt;/p&gt;

&lt;p&gt;Ultimately I did manage to find a lot of bugs in my implementation of
the interpreter using the contracts. Obviously, though, I was driving
the process by generating terms and not using a systematic methodology
of proving the correctness–I have tried to say that the interpreter
generates certificates, but it is of course not certified. It’s a fun
exercise, though–you can read the full code yourself below. I think
there are a few follow ups that could be done from here if you are
interested in experimenting with the code. Adding closures and
application, for example, should not be too hard; I may illustrate
that in my course next term.&lt;/p&gt;

&lt;p&gt;Thanks to Quinn Wilton for some corrections to the phrasing in this
post.&lt;/p&gt;

&lt;h3 id=&quot;the-code&quot;&gt;The Code&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; self-certifying interpreters, summer 2022, kris micinski
#lang racket

;; naturals
(define (nat? n)
  (match n [&apos;O #t] [`(S ,(? nat? n)) #t] [_ #f]))

(define/contract (num-&amp;gt;nat n)
  (-&amp;gt; nonnegative-integer? nat?)
  (match n
    [0 &apos;O]
    [n `(S ,(num-&amp;gt;nat (- n 1)))]))

(define/contract (nat-&amp;gt;num n)
  (-&amp;gt; nat? nonnegative-integer?)
  (match n
    [&apos;O 0]
    [`(S ,x) (add1 (nat-&amp;gt;num x))]))

(define/contract (nat-add s0 s1)
  (-&amp;gt; nat? nat? nat?)
  (match s0
    [&apos;O s1]
    [`(S ,s0+) `(S ,(nat-add s0+ s1))]))

;; values are nats
(define value? nat?)

;; expressions
(define (expr? e)
  (match e
    [(? nonnegative-integer? n) #t]
    [(? symbol? x) #t]
    [`(let ,(? symbol? x) ,(? expr? e) ,(? expr? e-body)) #t]
    [`(plus ,(? expr? e0) ,(? expr? e1)) #t]
    [`(not ,(? expr? e-guard)) #t]
    [`(if0 ,(? expr? e0) ,(? expr? e1) ,(? expr? e2)) #t]
    [_ #f]))

;; environments
(define (environment? ρ)
  (match ρ
    [&apos;∅ #t]
    [`(↦ ,(? environment? ρ+) ,(? symbol? x) ,(? value? v)) #t]
    [_ #f]))

;; environment lookup -- predicate (inductive defn.)
(define/contract (env-maps? pf ρ x v)
  (-&amp;gt; any/c environment? symbol? value? boolean?)
  (match pf
    [`(↦-hit
       ------
       (↦ ,ρ ,x0 ,v0))
     (and (equal? x0 x) (equal? v0 v))]
    [`(↦-miss
       ,next-pf
       -----
       (↦ ,ρ ,x0 ,_))
     (and (not (equal? x0 x))
          (env-maps? next-pf ρ x v))]
    [_ #f]))

;; decision procedure for lookup -- returns witness and proof of inclusion
(define/contract (lookup ρ x)
        ;; v---- domain ----v
    (-&amp;gt;i ([ρ environment?] [x symbol?])
        ;; range -- produces a proof dependent on ρ,x
         [result (ρ x)
                 (lambda (witness-pf) (match witness-pf
                                        [`(,(? value? v) . ,pf) (env-maps? pf ρ x v)]
                                        [_ #f]))])
  (match ρ
    [`(↦ ,ρ1 ,x1 ,v) #:when (equal? x1 x)
                     `(,v . (↦-hit ------ (↦ ,ρ ,x ,v)))]
    [`(↦ ,ρ1 ,x1 ,v) #:when (not (equal? x1 x))
                     (match (lookup ρ1 x)
                       [`(,v . ,pf)
                        `(,v . (↦-miss ,pf ----- (↦ ,ρ1 ,x1 ,v) ))])]))

; (lookup &apos;(↦ (↦ ∅ x O) y (S O)) &apos;x)

;; we will now follow the style &apos;(name atecedent0 ... ----- consequent)
(define (consequent judgement) (last judgement))

;; predicate -- inductive definition of evaluation relation
(define/contract (⇓ pf e ρ v)
  (-&amp;gt; any/c expr? environment? value? boolean?)
  (match pf
    ;; Const
    [`(⇓-const
       -----
       (,(? nonnegative-integer? n) ,ρ+ ⇓ ,v+))
     #:when (and (equal? (num-&amp;gt;nat n) v) (equal? ρ+ ρ) (equal? v v+))
     #t]
    ;; Var
    [`(⇓-var ,proof-x-in-ρ
       -----
       (,(? symbol? x) ,(? environment? ρ+) ⇓ ,(? value? v+)))
     #:when (and (equal? ρ+ ρ) (equal? v+ v))
     (env-maps? proof-x-in-ρ ρ x v)]
    ;; Let
    [`(⇓-let
       ,proof-e0
       ,proof-e1
       -----
       ((let ,(? symbol? x) ,(? expr? e0) ,(? expr? e1)) ,(? environment? ρ+) ⇓ ,(? value? v+)))
     #:when (equal? v+ v) (equal? ρ+ ρ)
     (and (⇓ proof-e0 e0 ρ (last (consequent proof-e0)))
          (⇓ proof-e1 e1 `(↦ ,ρ ,x ,(last (consequent proof-e0))) (last (consequent proof-e1))))]
    ;; Plus
    [`(⇓-plus
       ,proof-e0
       ,proof-e1
       (plus ----- (= (+ ,v0+ ,v1+) ,v-r))
       -----
       ((plus ,e0 ,e1) ,ρ+ ⇓ ,v-r))
     #:when (and (equal? v-r v) (equal? ρ+ ρ))
     (define v0 (last (consequent proof-e0)))
     (define v1 (last (consequent proof-e1)))
     (and (⇓ proof-e0 e0 ρ v0)
          (⇓ proof-e1 e1 ρ v1)
          (equal? v0+ v0)
          (equal? v1+ v1)
          (equal? v-r (nat-add v0 v1)))]
    ;; Not
    [`(⇓-not-0
       ,proof-e0
       -----
       ((not ,e0) ,ρ ⇓ O))
     (define v0+ (match (consequent proof-e0) [`(,_ ,_ ⇓ ,v) v]))
     (and (equal? v0+ v) (not (equal? v &apos;O)) (⇓ proof-e0 e0 ρ v))]
    [`(⇓-not-1
       ,proof-e0
       -----
       ((not ,e0) ,ρ ⇓ (S O)))
     (define v0+ (match (consequent proof-e0) [`(,_ ,_ ⇓ ,v) v]))
     (and (equal? v0+ v) (equal? v &apos;O) (⇓ proof-e0 e0 ρ v))]
    ;; If-True
    [`(⇓-if-true
       ,proof-guard-true
       ,proof-e1-v-res
       -----
       ((if0 ,e0 ,e1 ,e2) ,ρ ⇓ ,v))
     (match (consequent proof-guard-true)
       [`(,_ ,_ ⇓ O)
        (and (⇓ proof-guard-true e0 ρ &apos;O)
             (⇓ proof-e1-v-res e1 ρ v))])]
    ;; If-False
    [`(⇓-if-false
       ,proof-guard-false
       ,proof-e1-v-res
       -----
       ((if0 ,e0 ,e1 ,e2) ,ρ ⇓ ,v+))
     #:when (equal? v+ v)
     (match (consequent proof-guard-false)
       [`(,_ ,_ ⇓ ,n)
        (and (not (equal? n &apos;O))
             (⇓ proof-guard-false e0 ρ n)
             (⇓ proof-e1-v-res e1 ρ v))])]
    [_ #f]))

;;
;; Self-certifying interpreter
;;

;; produce a value alongside a proof of its correctness
(define/contract (eval e ρ)
  ;; contract: returns pair of value and proof of its derivation
  (-&amp;gt;i ([e expr?] [ρ environment?])
       [result (e ρ)
               (lambda (witness-pf) (match witness-pf
                                      [`(,(? value? v) . ,pf) (⇓ pf e ρ v)]
                                      [_ #f]))])
  (match e
    [(? nonnegative-integer? n)
     (cons (num-&amp;gt;nat n)
           `(⇓-const
             -----
             (,n ,ρ ⇓ ,(num-&amp;gt;nat n))))]
    [(? symbol? x)
     (match (lookup ρ x)
       [`(,v . ,pf)
        (cons v `(⇓-var
                  ,pf
                  -----
                  (,x ,ρ ⇓ ,v)))])]
    [`(let ,x ,e ,eb)
     (match (eval e ρ)
       [`(,v . ,pf-e)
        (match (eval eb `(↦ ,ρ ,x ,v))
          [`(,v-res . ,pf-v)
           (cons v-res
                 `(⇓-let
                   ,pf-e
                   ,pf-v
                   -----
                   ((let ,x ,e ,eb) ,ρ ⇓ ,v-res)))])])]
    [`(plus ,e0 ,e1)
     (match-define `(,v0 . ,pf-v0) (eval e0 ρ))
     (match-define `(,v1 . ,pf-v1) (eval e1 ρ))
     (define v-res (nat-add v0 v1))
     (cons v-res
           `(⇓-plus
             ,pf-v0
             ,pf-v1
             (plus ----- (= (+ ,v0 ,v1) ,v-res))
             -----
             ((plus ,e0 ,e1) ,ρ ⇓ ,v-res)))]
    [`(not ,e)
     (match (eval e ρ)
       [`(0 . ,pf-e)
        (cons &apos;(S O)
              `(⇓-not-1
                ,pf-e
                -----
                ((not ,e) ρ ⇓ (S O))))]
       [`(,v0 . ,pf-e)
        (cons &apos;O
              `(⇓-not-0
                ,pf-e
                -----
                ((not ,e) ρ ⇓ O)))])]
    [`(if0 ,e0 ,e1 ,e2)
     (match (eval e0 ρ)
       [`(O . ,pf-e0)
        (match (eval e1 ρ)
          [`(,v . ,pf-v)
           (cons v
                 `(⇓-if-true
                   ,pf-e0
                   ,pf-v
                   -----
                   ((if0 ,e0 ,e1 ,e2) ,ρ ⇓ ,v)))])]
       [`(,n . ,pf-e0)
        (match (eval e2 ρ)
          [`(,v . ,pf-v)
           (cons v
                 `(⇓-if-false
                   ,pf-e0
                   ,pf-v
                   -----
                   ((if0 ,e0 ,e1 ,e2) ,ρ ⇓ ,v)))])])]))

;; nice latex; comment out the labels by adding a % before \\tiny
(define (pf-&amp;gt;tex pf)
  (define name (first pf))
  (define antecedents (reverse (list-tail (reverse (list-tail (cdr pf) 0)) 2)))
  (foldr
   (lambda (k v acc) (string-replace acc k v))
   (format &quot; \n \\frac{ ~a }{ \\texttt{ ~a } }}&quot;
           name
           (string-join (map pf-&amp;gt;tex antecedents) &quot;\\,&quot;)
           (consequent pf))
   &apos;(&quot;⇓&quot; &quot;∅&quot; &quot;↦&quot;)
   &apos;(&quot;\\ensuremath{\\Downarrow}&quot; &quot;\\ensuremath{\\emptyset}&quot; &quot;\\ensuremath{\\mapsto}&quot;)))

(define (derive e)
  (displayln (pf-&amp;gt;tex (cdr (eval e &apos;∅)))))

;; examples

;(derive &apos;(let x (plus 0 (if0 (plus 0 0) 1 0)) (plus x 0)))
;(derive &apos;(plus 1 (if0 0 1 2)))
;(derive &apos;(let x (plus 0 0) (plus x 1)))

(define (eval-simpl e ρ)
  (match e
    [(? nonnegative-integer? n) n]
    [(? symbol? x) (hash-ref ρ x)]
    [`(let ,x ,e ,eb)
     (eval-simpl eb (hash-set ρ x (eval-simpl e ρ)))]
    [`(plus ,e0 ,e1) (+ (eval-simpl e0 ρ) (eval-simpl e1 ρ))]
    [`(not ,e)
     (match (eval-simpl e ρ)
       [0 1]
       [_ 0])]
    [`(if0 ,e0 ,e1 ,e2)
     (match (eval-simpl e0 ρ)
       [0 (eval-simpl e1 ρ)]
       [_ (eval-simpl e2 ρ)])]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sun, 14 Aug 2022 00:00:00 -0400</pubDate>
        <link>/certifying-interpreters</link>
        <guid isPermaLink="true">/certifying-interpreters</guid>
        
        
        <category>dependent-types,</category>
        
        <category>functional-programming,</category>
        
        <category>theorem-proving</category>
        
      </item>
    
      <item>
        <title>Why I hope you&apos;ll submit to Scheme Workshop</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://thomas.gilray.org/scheme-2019/&quot;&gt;&lt;strong&gt;Link to this year’s Scheme Workshop CFP&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This year marks the twentieth anniversary of the workshop on &lt;a href=&quot;http://www.schemeworkshop.org/&quot;&gt;Scheme
and Functional Programming&lt;/a&gt;. The
Scheme Workshop represents a diverse community of hackers, academics,
and enthusiasts. The workshop offers a forum to share insights,
experience, and technical developments of and within the Scheme family
of programming languages. Rather than focus on a specific
implementation or community, workshop attendees are united by an
appreciation for succinct expression of novel ideas realized via
programming. The submission deadline is &lt;strong&gt;May 24th, 2019&lt;/strong&gt;, I hope
you’ll help us celebrate by submitting a paper!&lt;/p&gt;

&lt;h4 id=&quot;what-is-scheme-workshop&quot;&gt;What is Scheme Workshop?&lt;/h4&gt;

&lt;p&gt;The Scheme Workshop website describes it as a…&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Yearly meeting of programming language practitioners who share an
  aesthetic sense embodied by the Algorithmic Language Scheme:
  universality through minimalism, and flexibility through rigorous
  design.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here’s my personal take. I love Scheme Workshop because it brings
together a group of people with a truly unique perspective on
programming. We represent a diverse background, but a shared vision:
to distill insights about programming to their most economic
presentation. We appreciate thoughtful, comprehensible solutions to
challenging problems. We challenge ourselves to step outside of our
boundaries and build fundamentally new paradigms for expressing
ideas. Our mission is to build a community where we foster diversity,
education, and support each other in pursuit of these ideals.&lt;/p&gt;

&lt;p&gt;Scheme Workshop is unique in that it is:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Open to everyone who cares about Scheme-ish ideas&lt;/strong&gt;. Instead of
   focusing on promoting the most cutting edge results, Scheme
   Workshop centers around thoughtful discussions relating to unique
   ideas that embody the ethos of Scheme. You don’t have to be an
   academic to attend; in fact, we have a rich history of
   participation from hobbyists and industrial attendees.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Non-archival and open access&lt;/strong&gt;. We aim to support and foster unique
  ideas. Naturally, some of these ideas may grow into work
  eventually submitted to research conferences. Scheme Workshop
  provides a platform for researchers to get perspective from the
  Scheme community on their work at all stages of development. While
  we publish a technical report of submitted papers, submission to
  Scheme Workshop does not preclude subsequent submission to
  archival research conferences. In fact, we see Scheme Workshop as
  an ideal proving ground for groundbreaking research ideas. We hope
  that the discussions generated by the presentation of those ideas
  at Scheme Workshop will productively inform the authors’
  scholarship.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Supportive of off-the-wall ideas&lt;/strong&gt;. There are some ideas that
  are really interesting, kind of zany, and just inspire us in a
  deep way we can’t quite put our finger on. These ideas aren’t
  necessarily the kind that would fit well at a programming-oriented
  conference, but they might not be a good fit for research
  conferences either. Scheme Workshop is a perfect venue for these
  kinds of ideas. You’ll find like-minded people who enjoy
  challenging their perspectives on what programming even means.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;A great place for your first paper&lt;/strong&gt;. We place an emphasis on
  giving thoughtful, high-quality, and friendly reviews. We also
  have a strong appreciation for “half-baked” ideas. When I was a
  beginning PhD student, submitting to so-called top conferences
  often felt overwhelming. Scheme Workshop wants to help budding
  researchers develop their writing and presentation. Similarly, we
  realize that great ideas can come from people in industry, the
  open-source community, or the broader hobbyist community. We work
  hard to ensure that their ideas are taken seriously and give them
  the feedback they deserve.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;what-about-racket-haskell-clojure-sml-c-etc&quot;&gt;What about Racket, Haskell, Clojure, SML, C++, etc…?&lt;/h4&gt;

&lt;p&gt;The language isn’t what’s important, it’s the idea. We want the
workshop to be filled with exciting talks that broaden our horizons
and challenge us to think about programming in a way we wouldn’t have
before. I could easily imagine relevant papers dealing with template
metaprogramming in C++, hygiene in OCaml, or domain-specific languages
in Clojure.&lt;/p&gt;

&lt;p&gt;If you think your idea &lt;em&gt;might&lt;/em&gt; be relevant to the workshop, please
don’t hesitate to contact Tom and myself. We’ll gladly give you
an honest assessment of whether your idea would be a good fit. If not,
we’ll do our best to direct you towards an appropriate venue for your
ideas.&lt;/p&gt;

&lt;h4 id=&quot;who-should-submit&quot;&gt;Who should submit?&lt;/h4&gt;

&lt;p&gt;Traditionally, submissions to Scheme Workshop come from those within
or adjacent to academia. However, this is &lt;strong&gt;not&lt;/strong&gt; a requirement. We
welcome submissions from everyone who thinks they have something
thoughtful to say to the Scheme community. This year, I want to
specifically encourage submissions from:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Undergraduate or graduate students who are looking for practice
writing papers on their own. It can be a challenge to develop your
own sense of research style. Scheme Workshop is a great place to get
feedback on your work in a low-stakes environment. Rather than judge
the quality of your work against a high technical bar, we want to
help build your ideas and presentation so that you can be proud of
the way you’re articulating them.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;People within the tech industry who have never written an academic
paper before. Scheme Workshop leans a bit more academic than
conferences such as RacketCon and StrangeLoop. However, this doesn’t
mean we don’t value ideas from industry. If you’re in industry and
would like to write a paper but aren’t sure how, please reach out to
me: I’m happy to Skype with you and speak frankly about how the
process works.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Seasoned Scheme wizards. Scheme Workshop has a long history of
insightful talks from key contributors to the Scheme community. These
community members shape our vision, and guide newcomers (such as
myself!) by helping us understand the key principles that embody the
Scheme community.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;some-random-scheme-workshop-papers-i-liked&quot;&gt;Some random Scheme Workshop papers I liked&lt;/h4&gt;

&lt;p&gt;There’s truly been some amazing work at Scheme Workshop over the
years.  I can’t hope to summarize it all here. Instead, I picked a
random collection of papers to help you get an idea of the workshop’s
direction.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://schemeworkshop.org/2006/15-barzilay.pdf&quot;&gt;A Self-Hosting Evaluator using
HOAS&lt;/a&gt;, by Eli
Barzilay. This paper discusses how–when you’re implementing a
Scheme interpreter in Scheme–you can avoid implementing
substitution by reflecting lambdas from the source language into the
metalangauge (which still gives you means of abstracting, e.g.,
control structure). This is a neat idea that is the perfect size for
Scheme Workshop.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://scheme2006.cs.uchicago.edu/03-mccarthy.pdf&quot;&gt;Interaction-Safe State for the
Web&lt;/a&gt; by Jay
McCarthy and Shriram Krishnamurthi. This paper discusses new
linguistic mechanisms for building abstractions for how we
understand navigation within web applications. I think this idea
nicely combines the practice of building web applications correctly
with the linguistic abstraction mechanisms afforded by Scheme.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://users.cs.northwestern.edu/~robby/pubs/papers/scheme2007-wf.pdf&quot;&gt;Well-typed programs can’t be
blamed&lt;/a&gt;
by Philip Wadler and Robby Findler. This paper from 2007 appears to
be an earlier version of the highly influential 2009 ESOP paper of the
same name.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.ccs.neu.edu/home/dherman/research/papers/scheme08-stack-marks.pdf&quot;&gt;Implementing Continuations Marks in
JavaScript&lt;/a&gt;
by John Clements, Ayswarya Sundaram, and David Herman. This paper
discusses how continuation marks can be implemented in JavaScript. I
see this as an exciting paper exploring a novel idea in a new space,
and the authors mention some foundational challenges in scaling up
to languages that allow tail calls with conventional “return”-style
semantics.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://users.soe.ucsc.edu/~lkuper/papers/lambdae.pdf&quot;&gt;A pattern matcher for miniKanren–or–How to get into trouble with
CPS macros&lt;/a&gt;
by Andy Keep, Michael Adams, Lindsey Kuper, Will Byrd, and Dan
Friedman. This paper reveals an interesting ramification of writing
macros in a CPS-based style alongside conditional macro
expansion. They build a pattern matcher for the miniKanren
programming language, demonstrating the issue along the way. I like
that this paper reveals a foundational problem in macro engineering.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;help-us-build-a-community&quot;&gt;Help us build a community!&lt;/h4&gt;

&lt;p&gt;The goal of Scheme Workshop is to build a community that celebrates
the fun in presenting beautifully minimal ideas. We often masquerade
these ideas as programs. But we’re all bound together by the passion
we share for articulating our ideas in an elegant way. Programming
languages give us the ability to rapidly interact with our ideas,
breaking and rebuilding our realization of those ideas at a pace never
before seen by humanity. Scheme celebrates this opportunity by
allowing us unprecedented flexibility in the way we articulate and
execute these ideas.&lt;/p&gt;

&lt;p&gt;I hope that you share my excitement. If you do, I sincerely hope
you’ll consider submitting a paper to &lt;a href=&quot;https://thomas.gilray.org/scheme-2019/&quot;&gt;the twentieth workshop on
Scheme and Functional
Programming&lt;/a&gt;!&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Apr 2019 00:00:00 -0400</pubDate>
        <link>/research/functional-programming/scheme/2019/04/10/scheme-workshop/</link>
        <guid isPermaLink="true">/research/functional-programming/scheme/2019/04/10/scheme-workshop/</guid>
        
        
        <category>research</category>
        
        <category>functional-programming</category>
        
        <category>scheme</category>
        
      </item>
    
      <item>
        <title>Why Does Netflix See my Facebook Picture?</title>
        <description>&lt;p&gt;The other day I updated my Facebook profile picture. The thing I
didn’t realize was that when I changed it, Netflix also got it:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/facebook-netflix.png&quot; alt=&quot;A figure showing my Facebook profile picture on the left with an arrow pointing towards Netflix (getting my updated Facebook photo) on the right with a question mark over it (asking why)&quot; style=&quot;width:450px&quot; class=&quot;post-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This is pretty jarring. Where was the “share this with Netflix” button
that I pressed? Of course, the answer is that it’s right here:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/netflix-privacy.png&quot; alt=&quot;A picture of Facebook&apos;s privacy configuration for Netflix&quot; style=&quot;width:350px&quot; class=&quot;post-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It’s buried right there under “Public profile (required).” But there’s
also a lot of other stuff I gave it access to too, I guess I forgot
about that.&lt;/p&gt;

&lt;p&gt;But why does it need access to my Facebook account at all? I just
wanted to use Facebook so that I wouldn’t have to login to Netflix
using an email. It’s so easy to just click in with my Facebook
account, it’s everywhere!&lt;/p&gt;

&lt;p&gt;The answer, of course, is twofold: Netflix wants to give me a more
personalized experience (so they can beat out other video services)
and because they want to filter it into giant machine learning
algorithms to sell me ads and learn stuff about me.&lt;/p&gt;

&lt;p&gt;So I knew all of that, but I &lt;em&gt;still&lt;/em&gt; didn’t stop and think about
Netflix getting my new profile picture whenever I changed it. Wow. I
wonder what else does that!&lt;/p&gt;

&lt;p&gt;Turns out it’s &lt;em&gt;hundreds&lt;/em&gt; of things! Facebook even has a tool for
this, called their “Privacy Checkup”:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/facebook-privacy-checkup.png&quot; alt=&quot;A picture of Facebook&apos;s privacy checkup tool&quot; style=&quot;width:400px&quot; class=&quot;post-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This is useful for helping you audit which apps have access to do
things like post on your feed and things like that. But it doesn’t
show you more nuanced things.&lt;/p&gt;

&lt;p&gt;Here’s the big problem with all of this:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There’s a gap between what Netflix is actually &lt;strong&gt;using&lt;/strong&gt;, and what I
think it &lt;strong&gt;needs&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When I think about Netflix using my Facebook, I think it’s just
because I’m logging on. But what I don’t see is that Netflix is using
so much more! It’s connecting me with my friends, looking at my likes,
and using that information to improve my experience.&lt;/p&gt;

&lt;p&gt;And what’s more, Netflix probably thinks that it’s okay to do this,
because after all, I agreed to it! And to be honest, they’re not
totally wrong.&lt;/p&gt;

&lt;p&gt;But I build my mental model of what Netflix is accessing based on what
I &lt;em&gt;see&lt;/em&gt; it doing, not the policy that I have to go read in a dark
corner of Facebook’s privacy section (no offense to Facebook).&lt;/p&gt;

&lt;h2 id=&quot;background-uses-are-tricky&quot;&gt;Background Uses Are Tricky&lt;/h2&gt;

&lt;p&gt;I contend that the main problem here is that humans are very poor at
envisioning how apps will use our information in the “background.” The
background is a hazy thing, but by the background I basically mean,
“during a time at which I haven’t directly instructed the app to use
my information by an explicit interaction (e.g., pressing a button)”&lt;/p&gt;

&lt;p&gt;Humans are very &lt;em&gt;good&lt;/em&gt; at understanding that their information will be
used after taking some direct action. For example, after I click
“share location” it’s extremely obvious that my location will be
used. But we’re really bad at predicting (or remembering) what might
happen when it’s been six months since we installed the app.&lt;/p&gt;

&lt;p&gt;Here’s another example I noticed just today. I added some new contacts
to the phone book on my iPhone. Later, I went to use Skype. I’m not a
big fan of Skype: every other week it seems like someone’s Skype
account has been hacked, so I can’t say I have a huge amount of trust
in it. Of course, when Skype installed it basically forced me to allow
it to access my contacts. Okay, that seems sensible, so I let it. But
I didn’t realize that it would &lt;em&gt;constantly&lt;/em&gt; get my contacts whenever I
changed them. I allowed access, of course, but I didn’t really “see”
Skype accessing my contacts, so why would I be surprised.&lt;/p&gt;

&lt;p&gt;We found the same result in &lt;a href=&quot;http://kmicinski.com/assets/apptracer.pdf&quot;&gt;my CHI ‘17
paper&lt;/a&gt;, where we measured
user expectations of permission usage within a set of vignette Android
apps. Users were overwhelmingly more likely to expect access to
permissions after they took a direct action, but were much less likely
to expect that data was being accessed when that data was used in the
background. (I’ll be giving this talk again at &lt;a href=&quot;https://www.ftc.gov/news-events/events-calendar/2018/02/privacycon-2018&quot;&gt;PrivacyCon
2018&lt;/a&gt;
later this year!)&lt;/p&gt;

&lt;p&gt;And that was just for apps! Imagine how complicated it is when you’re
not just on your phone, you’re using some nebulous cloud-based
service. What’s worse: most apps have many different components,
interact with several different APIs (Facebook, Google, Twitter,
etc…), each of them using their own privacy GUIs that constantly
update and change.&lt;/p&gt;

&lt;p&gt;My frank guess is that users don’t really have any idea what’s
happening until they see it. In fact, in our CHI ‘17 paper we also
found that users are more likely to expect access when they see some
indication of it (e.g., a banner on the top of the screen associated
with the use of that permission, like a “free coffee at your local
MegaCoffee” coupon). But that’s not very satisfying: what about all of
the other data access they never even see?&lt;/p&gt;

&lt;h2 id=&quot;possible-solutions-better-defaults-reminders-and-audits&quot;&gt;Possible Solutions: Better Defaults, Reminders, and Audits&lt;/h2&gt;

&lt;p&gt;I’m not sure what all of the answers are, but I have a few high-level
points that I take away from it:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Users are very poor at reasoning about data access when the access
is far removed from the authorization decision.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;They are even &lt;em&gt;worse&lt;/em&gt; when there’s no apparent &lt;em&gt;reason&lt;/em&gt; why the
access occurs. In fact, this is almost downright
malicious. Permissions are only so coarse, and while Netflix has
access to a bunch of things in my “public profile”, I’d never expect
it to use all of them (even though I know it does).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We should educate users on how / why background uses occur, and
explain their relevance to app behavior if possible.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When we’re using coarse permissions, like “Public Profile”, we
should realize that users will only expect a subset of that data to
be used and act accordingly.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So the first thing I think we can do is better defaults. For example,
Apple seems to have taken this hint. Apps can now simply request data
never and “when in use”. This is a pretty intuitive thing, since users
are pretty poor at conceptualizing the computational models of
apps. They also go a step further and show you this nice dialog when
apps have been using data in the background (I’m honestly not sure how
this occurs on iOS these days):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ios-bg-loc.jpg&quot; alt=&quot;A picture showing how iOS alerts users to background location usage&quot; style=&quot;width:200px&quot; class=&quot;post-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This is nice because it helps the user “audit” which apps have been
using their data. In our paper, we found that one concrete way to help
users understand background usage on Android was to ask for permission
right on startup before any other app functionality appeared. My
hypothesis is that users said “well the app hasn’t done anything yet,
so it must just need this all the time.” Still, I think that’s not a
very good compromise: users will tend to associate that the
information is only being used when the app appears to be using it. So
we should really confine data access to when users can observe it
happening.&lt;/p&gt;

&lt;p&gt;Another concrete way I see this improving is better auditing tools to
help users understand where their data will go. For example, I could
imagine implementing a tool that goes through your various social
networks and plays something like 20-questions with you: “do you know
that when you change your Facebook picture your FindMeSingles apps is
going to see it?” or something of the like. We’d need to do research
to help understand the best examples to present, but I think this
would be a cool idea since users reason well about examples and bad
about very general policies.&lt;/p&gt;

&lt;p&gt;A few research-y things I’m working on right now address this in a few
ways:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Using dynamic analysis to measure when social media permissions are
being used in apps. We’re in the early stages of this (still
scraping apps from Google Play, let me know if you know of a better
way / a good way to get a bunch of apps!), but I think this will
provide some good ground truth on how apps are using these social
media permissions. Of course, there are limitations here. For
example, apps could pair with a web service to do the dirty work,
but I think this is a good first step.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Log-guided program analysis that helps analysts understand &lt;em&gt;why&lt;/em&gt;
apps use permissions. Our tools use relatively cheap tricks to
enable (unsound) program analyses to scale to very large apps
(Bumble, Tinder, Slack) and precisely explain why permissions are
used. We do this by using &lt;em&gt;logs&lt;/em&gt; from those programs to guide the
analysis.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Analysis-based support for lowering the performance overhead of
dynamic information-flow analyses. Since many web systems are
written using dynamic languages (e.g., Python), I’m excited about
the possibilities of using off-the-shelf tools (like
&lt;a href=&quot;https://github.com/jeanqasaur/jeeves&quot;&gt;Jeeves&lt;/a&gt;) to specify
information-flow policies that connect up to the GUI in a principled
way (similar to what I did in &lt;a href=&quot;http://kmicinski.com/assets/clickrelease.pdf&quot;&gt;my ESORICS ‘15
paper&lt;/a&gt;). The problem
with these systems is that they do induce some runtime overhead, but
we’re hoping to eliminate much of that by using intelligent program
analysis techniques.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Longer-term, I’m interested in driving my research to understand how
users conceptualize these permissions. What does that say about how we
can visualize and enforce them? I’m specifically interested in
cross-app policies: where the data goes from the camera app on your
phone, to Instagram, to your friend’s parents after your friend clicks
“like” on the image (and their parents then see it in their
feed). These decisions are nuanced, and seem especially hard to
explain to users. But as we have more and more apps, I think getting a
handle on these things will be essential. And once we do that, we can
(hopefully) start using cool language-based techniques to help enforce
these policies!&lt;/p&gt;
</description>
        <pubDate>Tue, 02 Jan 2018 00:00:00 -0500</pubDate>
        <link>/privacy/research/2018/01/02/privacy-user-understanding/</link>
        <guid isPermaLink="true">/privacy/research/2018/01/02/privacy-user-understanding/</guid>
        
        
        <category>privacy</category>
        
        <category>research</category>
        
      </item>
    
      <item>
        <title>Video: Exploiting Use After Free (UAF) vulnerabilities</title>
        <description>&lt;p&gt;&lt;strong&gt;Obligatory&lt;/strong&gt;: I must point out that my inspiration for this post was
a &lt;a href=&quot;https://www.youtube.com/watch?v=ZHghwsTRyzQ&quot;&gt;really nice video on
YouTube&lt;/a&gt;. I don’t claim
to have invented this idea, I just wanted to explain it in a way that
makes sense to me (although the YouTuber likely does a better job than
I).&lt;/p&gt;

&lt;p&gt;Today in my class we talked a bit about memory safety and
allocation. We’ve talked a decent amount about pointers, but haven’t
had any projects where students are required to use
allocation. Instead, we’re (so far) relying on RAII from library
classes to get students through their programming. My suspcion is that
students are probably too eager to use pointers without understandign
their vagaries, because that’s what I did when I started programming
in C.&lt;/p&gt;

&lt;p&gt;So as a bit of fun (and preparation for my course next semester), I
made a video showing how these vulnerabilities work.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Here’s a &lt;a href=&quot;https://github.com/kmicinski/cmsc245examples/blob/master/c%2B%2B/uaf.cc&quot;&gt;link to the code&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Here’s a &lt;a href=&quot;https://hc.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=6a2b42fb-4e24-4837-8220-97935db6a53b&quot;&gt;link to the video&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 10 Nov 2017 00:00:00 -0500</pubDate>
        <link>/security/videos/memory-safety/use-after-free/2017/11/10/uaf/</link>
        <guid isPermaLink="true">/security/videos/memory-safety/use-after-free/2017/11/10/uaf/</guid>
        
        
        <category>security</category>
        
        <category>videos</category>
        
        <category>memory-safety</category>
        
        <category>use-after-free</category>
        
      </item>
    
      <item>
        <title>Job materials for 2017</title>
        <description>&lt;p&gt;I’m applying to colleges and universities again in 2017. I’m very
happy at Haverford, but I’m on the lookout for a tenure-track spot at
a place that has students and colleagues that will excite me in the
same way I’m feeling right now:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/assets/research.pdf&quot;&gt;My research statement (4 12-point pages)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/assets/teaching.pdf&quot;&gt;My teaching statement (2 12-point pages)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 09 Nov 2017 00:00:00 -0500</pubDate>
        <link>/application</link>
        <guid isPermaLink="true">/application</guid>
        
        
        <category>git</category>
        
        <category>talks</category>
        
      </item>
    
      <item>
        <title>All About Git</title>
        <description>&lt;p&gt;I’m giving a college-wide talk for FIG (Fig is Good) tonight. FIG is a
student computing group. I’m hoping to record the talk, but for now
I’ll just put the slides here.&lt;/p&gt;

&lt;iframe src=&quot;https://www.icloud.com/keynote/0dhlSy84VggwTIhJdxjvGiTOQ?embed=true&quot; width=&quot;640&quot; height=&quot;500&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;1&quot; referrer=&quot;no-referrer&quot;&gt;&lt;/iframe&gt;
</description>
        <pubDate>Thu, 09 Nov 2017 00:00:00 -0500</pubDate>
        <link>/git/talks/2017/11/09/git-tutorial/</link>
        <guid isPermaLink="true">/git/talks/2017/11/09/git-tutorial/</guid>
        
        
        <category>git</category>
        
        <category>talks</category>
        
      </item>
    
  </channel>
</rss>
