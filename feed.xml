<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kristopher Micinski</title>
    <description>Kris Micinski's Website. Love the lambda.
</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 16 Dec 2022 10:28:02 -0500</pubDate>
    <lastBuildDate>Fri, 16 Dec 2022 10:28:02 -0500</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>Hyperproperties and why they're hard</title>
        <description>&lt;p&gt;Computer security as a field is met with a persistent criticism:
flashy attacks are
&lt;a href=&quot;https://twitter.com/AndrewCMyers/status/1579120278759563265&quot;&gt;hot&lt;/a&gt;,
boring (hard-fought) defenses are
&lt;a href=&quot;https://www.ieee-security.org/CSFWweb/goodessay.html&quot;&gt;not&lt;/a&gt;. Compared
to security, programming language theory seems relatively adept at
transitioning research to mainstream practice (e.g., Rust and the
popularity of Haskell). By contrast, it would appear many of the
innovations in security have been relatively engineering-focused in
nature: W^X, ASLR, and the like. As someone who does research in this
space myself, I have wondered why this is; while I think the reasons
are myriad, I think a central challenge is the intrinsic need in
security to reason about the ever-elusive hyperproperties.&lt;/p&gt;

&lt;h2 id=&quot;properties&quot;&gt;Properties&lt;/h2&gt;

&lt;p&gt;The &lt;em&gt;properties&lt;/em&gt; of a program are mathematical statements we can make
about it’s traces. For example, consider the following program:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while true:          # 0
  if (n % 2 == 0):   # 1
    n := n/2         # 2
  else:              # 3
    n := 3*n + 1     # 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What could traces of this program’s execution look like? If &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; is
known, we might say it is the sequence of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; paired with the
appropriate line number. For example, if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; starts at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;⟪0, n=5⟫, ⟪1, n=5⟫, ⟪4, n=5⟫, ⟪0, n=16⟫, ⟪1, n=16⟫, ⟪2, n=16⟫, ⟪0, n=8⟫,
⟪1, n=8⟫, ⟪2, n=8⟫, ⟪0, n=4⟫, ⟪1, n=4⟫, ⟪2, n=4⟫, ⟪0, n=2⟫, ⟪1, n=2⟫, 
⟪2, n=2⟫, ⟪0, n=1⟫, ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Each trace is (countably) infinite in size, without loss of generality
(as a terminating program may be thought of as infinitely repeating a
final &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skip&lt;/code&gt; state). Quantifying over the input is possible by
producing an infinite set of (infinite) traces. For example, one
property of the above (set of) traces is this: the suffix of every
trace is the (infinite loop) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⟪0, n=4⟫, ⟪1, n=4⟫, ⟪2, n=4⟫, ⟪0, n=2⟫,
⟪1, n=2⟫, ⟪2, n=2⟫, ⟪0, n=1⟫, ...&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The trace-based nature inherent to this style of semantics is a core
challenge in checking properties of the associated programs, because
computers may only materialize a finite approximation of infinite
objects. Unfortunately, the exact nature of this approximation can
deeply impact the kind of properties which may be checked. This is
why the different approaches to program modeling and verification
often pair a representation with an intended logic:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Model checking allow the user to specify the program using a
domain-specific languages (see, e.g., &lt;a href=&quot;https://lamport.azurewebsites.net/tla/book-21-07-04.pdf&quot;&gt;Chapter 2.3 of the TLA+
book&lt;/a&gt;)
which compiles into an automaton. This is no coincidence: statements
in temporal logics also map cleanly to the same automata (an
extension of finite automata called Büchi automata), at which point
automata-theoretic constructions (intersection, complementation,
etc…) may be used.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Abstract interpretation recognizes that the infinite behavior may be
finitized by approximating values in the semantics as elements of a
lattice allow using a &lt;a href=&quot;https://www.di.ens.fr/~cousot/COUSOTpapers/publications.www/CousotCousot-POPL-77-ACM-p238--252-1977.pdf&quot;&gt;fixed-point theorem to obtain
tractability&lt;/a&gt;. In
this setting, a set of traces is often modeled as an abstract state
&lt;em&gt;graph&lt;/em&gt;, the deterministic nature of traces often being lost in the
(necessary) finite approximation; paths through the abstract state
graph then correspond to traces in the (infinite) semantics. Using
this style, an abstract interpreter materializes a state graph and
then checks a property (e.g., the inclusion of a specific data flow)
by examining this abstract representation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Symbolic execution keeps a &lt;em&gt;symbolic&lt;/em&gt; representation of the program
state, and thus produces symbolic traces. The problem is that
symbolic execution can only materialize finite portions of these
traces, and thus it is impossible to reason about infinite
behavior. Thus, a symbolic executor includes a “scheduler” which
picks how to explore paths to avoid unproductive exploration. A
central challenge in symbolic execution is how to avoid getting
stuck early on in the trace. This problem is avoided in (say)
abstract interpretation by allowing the abstract state graph to
discover spurious edges, allowing reasoning from the “middle” of the
program, but at the cost of adding traces not present in the
original program.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Axiomatic semantics (e.g., Hoare triples) allows the user to
annotate the program with specifications, which are subsequently
enumerated to “verification conditions.” The semantics, and thus the
set of traces, is implicitly represented as the set of valid program
states which would satisfy the necessary verification conditions at
any specific point in the program. Metatheoretic results justify the
way in which we may stitch these verification conditions together to
obtain an end-to-end correct program. Still no free lunch here,
however, as the programmer often needs to articulate tedious loop
invariants in an iterative process with the verification tool.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;safety-and-liveness&quot;&gt;Safety and Liveness&lt;/h2&gt;

&lt;p&gt;Surprisingly, all properties of programs can be broken down into a
combination of two things: a “safety” property, and a “liveness”
property.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Safety properties are things which can be refuted using finite
counterexamples. For example, if a program has a use-after-free
vulnerability, you will be able to demonstrate some exploit wherein
memory is freed and then subsequently (but in a finite time horizon)
accessed. I.e., “bad things don’t happen.”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Liveness properties are things which require some finite proof of
progress. The quintessential liveness examples are guaranteed
service or starvation freedom.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example, consider the following concurrent code, wherein process 1
and 2 operate concurrently:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;n := 0
sem := 1

Process 1:
  while true:
    take(sem)
    i := 0
    while (i != n):
      skip
    n := n + 1
    rel(sem)

Process 2:
  while true:
    take(sem)
    if (n &amp;gt;= 7)
      *NULL; // crash
    rel(sem)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Assuming a fair scheduler, the program will eventually
crash. Demonstrating this requires only that we enumerate a thread
schedule wherein we choose process 1 to take &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sem&lt;/code&gt; (at least) seven times. A
similar argument holds for any arbitrarily-picked natural number, thus
the statement we’re making is one of safety.&lt;/p&gt;

&lt;p&gt;Things that are crash-like (vulnerabilities, memory errors, etc…)
are often safety properties. In fact, safety properties are so common
it is not obvious that there are other kinds of properties. At least, this
is probably true for computer scientists, pained by their hours of
debugging safety properties. By contrast, liveness properties say that
“good things” happen eventually. Examples include guaranteed
availability and (surprisingly, perhaps) termination.&lt;/p&gt;

&lt;p&gt;Formally, a liveness property has the form: “for all traces t0, there
exists an extension t1 such that t0⋅t1 ⊨ P.” Termination is a simple
instance of this liveness template, where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; states that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1&lt;/code&gt; is a
stream of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;skip&lt;/code&gt; expressions. The fact that any trace property of a
program may be factored into a combination of a safety property and
liveness property follows from the topological interpretation where
(a) safety properties represent closed sets (of traces) and (b)
liveness properties represent open sets. I am not an expert on
liveness, and will instead point you at the &lt;a href=&quot;https://www.cs.cornell.edu/fbs/publications/DefLiveness.pdf&quot;&gt;main paper I’ve read on
it&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;properties-and-their-proofs&quot;&gt;Properties and Their Proofs&lt;/h2&gt;

&lt;p&gt;It is hard to understate how much work has been done in checking
safety and liveness properties of programs. Because safety properties
feel like crashes, and programmers really hate crashes, we have
naturally developed a huge amount of our programming culture around
methods designed to help us understand and avoid crashes. Broadly,
this breaks down into static checking / verification and dynamic
auditing / enforcement / logging. For example, the central aim of most
program analyses is to check safety properties of programs, including
avoidance of crashes, errors, and similar faults, and reifies in
vastly-different ways from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf&lt;/code&gt;-style debugging to abstract
interpretation and program analysis tools (like Astrée, Soot, and
DOOP), to program verification frameworks (like
&lt;a href=&quot;https://github.com/EasyCrypt/certicrypt&quot;&gt;CertiCrypt&lt;/a&gt;). This is not to
say there is no great work in the area (e.g., the &lt;a href=&quot;https://github.com/mmjb/T2&quot;&gt;Terminator
project&lt;/a&gt;), but rather that I think most of
us have a natural intuition for safety properties as programmers.&lt;/p&gt;

&lt;p&gt;Notice that one I have left out until now is type systems. Type
systems feel very different than the methods I described above,
because they are prescriptive in nature and do not so obviously lead
to a trace-based semantics. The semantics of a type system is designed
to be compositional in the manner of natural deduction, which feels
very different than the trace-based nature of safety and liveness
properties.&lt;/p&gt;

&lt;h2 id=&quot;hyperproperties&quot;&gt;Hyperproperties&lt;/h2&gt;

&lt;p&gt;Hyperproperties allow us to talk about multiple traces of a program at
the same time. It is not immediately clear why this would be useful,
but some of the most motivating examples are from computer
security. For example, consider the following program:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Process 1:
  while true:
    s = read(secret)
    if (s == 0):
	  o = 1
    else:
      o = 0

Process 2:
  while true:
    out(o)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;secret&lt;/code&gt; is a stream of secret (binary) values. Is it possible to
infer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;secret&lt;/code&gt; from the (buffered) output? Of course: we just change
the 1s to 0s. Formally, though, it’s a bit hard to think about a
general property that would allow us to speak about the relationship
between the input and the output that would avoid this.&lt;/p&gt;

&lt;p&gt;It turns out this kind of obliviousness or “noninterference” is a more
general kind of program property, a proper that can simultaneously
quantify over two traces at once. The original formulation applied to
sequential programs, for example:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (secret == 0):
  out = 1
else:
  out = 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The program does not leak information because for every trace &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t0&lt;/code&gt;, there
exists another trace &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1&lt;/code&gt; such that the outputs are equivalent but the
inputs are not. Informally: the output of the program does not depend
on the secret input. Extending the definition of noninterference to
concurrent systems proved hard because of a basic challenge: once the
thread schedule is tainted by a secret value (e.g., by branching on a
secret and then doing something schedule-specific), non-local
reasoning must be done to ensure the thread schedule’s safety–all the
hell of concurrent programming, doubled.&lt;/p&gt;

&lt;p&gt;This is the point at which I would say, off-hand, “a particularly cool
idea by Zdancewic and Myers is to &lt;a href=&quot;https://www.cs.cornell.edu/andru/papers/csfw03.pdf&quot;&gt;statically-ensure observational
determinism&lt;/a&gt;.”
But, as thinking over this, I realized: the coolest results for
&lt;em&gt;checking&lt;/em&gt; hyperproperties I can find are &lt;em&gt;intensional&lt;/em&gt; systems (a
type system, in this case) to ensure the &lt;em&gt;extensional&lt;/em&gt; guarantees
necessitated by hyperproperties.&lt;/p&gt;

&lt;h2 id=&quot;proofs-of-hyperproperties&quot;&gt;Proofs of Hyperproperties&lt;/h2&gt;

&lt;p&gt;Unlike proofs of safety and liveness, relatively little work has been
done on proofs for hyperproperties. This is no insult to people
working in this research direction; finding bugs in one trace at a
time is proving hard enough, it seems.&lt;/p&gt;

&lt;p&gt;I speculate that this is because each new advance in logics for safety
checking corresponded with advances to the intensional representation
used to check those properties. Model checking became a huge deal once
we realized there were relatively simple automata-theoretic algorithms
to do it, but also because of the advent of
&lt;a href=&quot;https://web.stanford.edu/class/cs357/cegar.pdf&quot;&gt;CEGAR-style&lt;/a&gt;
methods. By contrast, I think similar advances happen in security
coinciding with advances in intensional checking mechanisms for
hyperproperties. For example, the aforementioned CertiCrypt and
 &lt;a href=&quot;https://www.cs.cornell.edu/jif/&quot;&gt;Jif&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A unifying trick to much of this work is to make hyperproperties
become just regular properties by having the semantics generate
&lt;a href=&quot;https://link.springer.com/chapter/10.1007/978-3-642-21437-0_17&quot;&gt;&lt;em&gt;pairs&lt;/em&gt; of
traces&lt;/a&gt;,
and then cooking up a version of a hypersafety statement of interest
to speak about these pairs.  This draws a connection between
hyperproperties and the large body of literature on relational program
verification. In some of my own work, we tried to use ideas from
&lt;a href=&quot;https://projects.csail.mit.edu/jeeves/papers/plas07-austin.pdf&quot;&gt;faceted
execution&lt;/a&gt;
to push the pairs from the trace-level to &lt;a href=&quot;https://ieeexplore.ieee.org/document/9155136&quot;&gt;the value
level&lt;/a&gt;. In other work I
did on model checking for hyperproperties, we just used a product
construction—the CEGAR algorithm would need to be updated to refine
states appropriately, but we did not attempt that. These efforts are
rooted in the intuition that we may exploit the rich body of work from
program analyses and the like to immediately reason about these pairs
of traces, but there is no free lunch, and making the abstractions
work in practice is seriously challenging.&lt;/p&gt;

&lt;p&gt;However, I have come think many of these efforts may be ultimately
fruitless compared to using secure-by-construction building
blocks. Once you’re at the level of needing to reason about
noninterference, you’re already in a pretty serious threat
model—timing channels and the like are going to be ever-present, and
will necessitate increasingly-advanced program logics, CEGAR-style
reasoning, and similar technologies, I believe. Any state-based
abstraction of the program will be destined to imprecision which will
eventually fall apart if the abstraction is not tightly tied to (and
derived from) the program’s semantics in a predictable way, but the
necessary explosion of the state graph (from the product construction)
implies serious complexity-theoretic challenges here, I worry.&lt;/p&gt;

&lt;p&gt;Thus, I claim we haven’t and won’t see hyperproperties (as they are
now) take off as a general way to give us new innovations in proofs of
security properties for programs. Instead, like the innovations in
safety properties, I think we’ll see more and more specialized
hyperproperties gain steam hand-in-hand with new innovations in
checking those properties. But crucially, I think these will be
&lt;em&gt;intensional&lt;/em&gt; in nature: more security type systems, popular libraries
which provide secure communication channels whose API satisfies
hypersafety guarantees when used properly, “secure linking” DSLs at
the binary layer which ensure specific invariants to guarantee
end-to-end correctness. I claim the most useful security innovations
(bounds checking, bytecode verification, etc..) have truly been safety
properties, constructed and used in a way to guarantee (a specific
instance of) hypersafety in practice.&lt;/p&gt;
</description>
        <pubDate>Mon, 10 Oct 2022 00:00:00 -0400</pubDate>
        <link>/hyperproperties-hard</link>
        <guid isPermaLink="true">/hyperproperties-hard</guid>
        
        
        <category>dependent-types,</category>
        
        <category>functional-programming,</category>
        
        <category>theorem-proving</category>
        
      </item>
    
      <item>
        <title>Certifying Interpreters in Racket</title>
        <description>&lt;p&gt;When I began programming, I read a copy of Richard Steven’s “Programming in the UNIX Environment.” Ultimately, my early experimentations with C were a failure; however, I later read David Beazley’s “Python: Essential Reference,” and was quickly able to pick up the UNIX API via it’s much simpler (admittedly, largely due to Beazley’s writing) Python counterpart. After teaching my undergraduate PL courses in Scheme variants these past few years I have wondered if we can understand type theory’s operationalization (via proof objects) using a similar shift in perspective.&lt;/p&gt;

&lt;p&gt;Here, I rigorously define an interpreter which produces a certificate
of its own correctness—assuming you trust the correctness of our
metalanguage, which (in the interests of appeasing the more skeptical
among us) we treat as S-expression comparison. Here I use Racket, but
any similar dynamic language with matching (or, if in OO, virtual
methods) would work to illustrate the key ideas. I do use Racket’s
contracts to check certificates, though other implementations could
defer this to the end or even elide checking entirely.&lt;/p&gt;

&lt;h3 id=&quot;the-language&quot;&gt;The Language&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; Specification of IfArith's syntax as a Racket predicate
(define (expr? e)
  (match e
    [(? nonnegative-integer? n) #t]
    [(? symbol? x) #t]
    [`(let ,(? symbol? x) ,(? expr? e) ,(? expr? e-body))]
    [`(plus ,(? expr? e0) ,(? expr? e1)) #t]
    [`(not ,(? expr? e-guard)) #t]
    [`(if0 ,(? expr? e0) ,(? expr? e1) ,(? expr? e2)) #t]
    [_ #f]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(define e0 '(plus 2 1)) ;; 3
(define e1 '(plus 1 (if0 0 1 2))) ;; 2
(define e2 '(let x (plus 0 0) (plus x 1))) ;; 1 
(define e3 '(let x (plus 0 (if0 (plus 0 0) 1 0)) (plus x 0))) ;; 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;the-proofs&quot;&gt;The Proofs&lt;/h3&gt;

&lt;p&gt;Now the tricky part: we need to think about what proofs for evaluation
of terms in our little language look like. To be precise about it, we
need to define a relation: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e, ρ ⇓ v&lt;/code&gt;, such that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt; is an expression,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ρ&lt;/code&gt; is an environment (mapping variables to values) and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v&lt;/code&gt; is a
value. To be constructive about it, we need to algebraically define a
structure representing proofs that the evaluation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ρ&lt;/code&gt;
evaluates to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v&lt;/code&gt;. Following the Scheme tradition of homoiconicity, we
represent proofs as S-expressions themselves; inference rules using
pattern matching over these S-expressions to mirror the natural
deduction (big-step) style in which we would write our semantics on
paper. As an example, here’s a derivation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(if0 0 (plus 1 1) 0)&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(⇓-if-true
  (⇓-const ----- 
         (0 ∅ ⇓ O))
  (⇓-plus
   (⇓-const -----
        (1 ∅ ⇓ (S O)))
   (⇓-const -----
          (1 ∅ ⇓ (S O)))
   (plus -----
      (= (+ (S O) (S O)) (S (S O))))
   -----
   ((plus 1 1) ∅ ⇓ (S (S O))))
  -----
  ((if0 0 (plus 1 1) 0) ∅ ⇓ (S (S O))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Racket’s pattern matcher is, of course, very different than a more
elaborate matcher centered around higher-order unification in a
statically-typed setting. Manually explicating the unification becomes
a bit of a chore after a while; certainly a rebuke to the thought of
using this as a serious strategy for type theory, but at the same time
precisely the reason we’re doing it this way.&lt;/p&gt;

&lt;p&gt;Of course it would be possible (especially in such a simple semantics
as this) to define &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e, ρ ⇓ v&lt;/code&gt; using substitution to implement
variables; I explicitly materialize environments to (a) anticipate
closures (later) and (b) present a representational challenge upon
which I would like to expand a bit. Of course, using Racket as our
metalanguage, we could simply use hashes for environments. But
remember—we are trying to appease the pedants among us, thus
representation must be as symbolic as possible. Similarly, I represent
the naturals symbolically. I do allow myself a serious concession: I
internalize &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plus&lt;/code&gt;, as I elide &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fix&lt;/code&gt; in the source language. If this
disappoints you, I would say there’s no fundamental barrier; we could
easily-enough (via environments) implement application and then a
fixed-point combinator.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; naturals
(define (nat? n)
  (match n ['O #t] [`(S ,(? nat? n)) #t] [_ #f]))

(define/contract (num-&amp;gt;nat n)
  (-&amp;gt; nonnegative-integer? nat?)
  (match n
    [0 'O]
    [n `(S ,(num-&amp;gt;nat (- n 1)))]))

(define/contract (nat-&amp;gt;num n)
  (-&amp;gt; nat? nonnegative-integer?)
  (match n
    ['O 0]
    [`(S ,x) (add1 (nat-&amp;gt;num x))]))

(define/contract (nat-add s0 s1)
  (-&amp;gt; nat? nat? nat?)
  (match s0
    ['O s1]
    [`(S ,s0+) `(S ,(nat-add s0+ s1))]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To represent environments we define (a) a predicate dictating valid
structure for environments and (b) a predicate, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(env-maps? ρ x v
pf)&lt;/code&gt;, which defines the structure of valid proofs showing that
environment &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ρ&lt;/code&gt; maps variable &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; to value &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v&lt;/code&gt;. Both of these are in
the de-facto “trusted computing base,” in the sense that if your
definition of proofs is broken (i.e., don’t faithfully capture what
you want to prove) then it doesn’t matter that your interpreter
produces proofs. And, of course, this is the biggest drawback of using
an untyped language to do this—we only get some rough syntactic
checking, similar to tools such as Ott but not dependently-typed
languages or provers. To avoid completely defeating the purpose of our
exercise here, I have followed a bit of a trick to rely minimally on
Racket as a metatheory: because many objects internal to the semantics
(e.g., numbers, environments, and proofs) are represented purely
symbolically (as S-expressions), we primarily rely upon Racket for
S-expression equality and dispatch (matching). Aside from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plus&lt;/code&gt; our
semantics uses a very small subset of Racket: I believe essentially
either (equivalently) existential fixed-point logic (of a Herbrand
base comprising S-expressions) or constrained horn clauses (whose
background logic includes S-expression equality and
structurally-recursive addition).&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; environments
(define (environment? ρ)
  (match ρ
    ['∅ #t]
    [`(↦ ,(? environment? ρ+) ,(? symbol? x) ,(? value? v)) #t]
    [_ #f]))

;; environment lookup -- predicate (inductive defn.)
(define/contract (env-maps? pf ρ x v)
  (-&amp;gt; any/c environment? symbol? value? boolean?)
  (match pf
    [`(↦-hit
       ------
       (↦ ,ρ ,x0 ,v0))
     (and (equal? x0 x) (equal? v0 v))]
    [`(↦-miss
       ,next-pf
       -----
       (↦ ,ρ ,x0 ,_))
     (and (not (equal? x0 x))
          (env-maps? next-pf ρ x v))]
    [_ #f]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The implementation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(⇓ pf e ρ v)&lt;/code&gt; follows its natural deduction
counterpart (which I have not written down, but try to stylize via my
spacing). Our procedure checks the proof, recursively calling itself
to check subproofs—mirroring the top-down process you may follow on
a whiteboard to check the proof yourself, though Reynolds points out
that the order of sub-checks is inherited from the metalanguage (i.e.,
Racket’s control flow).&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; proofs of evaluation
(define/contract (⇓ pf e ρ v)
  (-&amp;gt; any/c expr? environment? value? boolean?)
  (match pf
    ;; Const
    [`(⇓-const
       -----
       (,(? nonnegative-integer? n) ,ρ+ ⇓ ,v+))
     (and (equal? (num-&amp;gt;nat n) v) (equal? v v+) (equal? ρ+ ρ))]
   ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Checking proofs for constants is easy. The rest of the rules follow
their natural deduction counterparts; the tedious part is the
administrative overhead required to implement the store-passing
construction. Of course my code is a bit smelly here; the ad-hoc use
of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;consequent&lt;/code&gt; points to a much cleaner refactoring that elides using
pairs of a return value and its proof in favor of projecting the value
from the proof, but the point here is to stick to what I think I’d end
up with doing it in an interactive proof assistant.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    ;; Var
    [`(⇓-var ,proof-x-in-ρ
       -----
       (,(? symbol? x) ,(? environment? ρ+) ⇓ ,(? value? v+)))
    (and (equal? ρ+ ρ) (equal? v+ v) (env-maps? proof-x-in-ρ ρ x v))]
    ;; Let
    [`(⇓-let
       ,proof-e0
       ,proof-e1
       -----
       ((let ,x ,e0 ,e1) ,(? environment? ρ+) ⇓ ,(? value? v+)))
     (and (equal? v+ v) (equal? ρ+ ρ)
          (⇓ proof-e0 e0 ρ (last (consequent proof-e0)))
          (⇓ proof-e1 e1 `(↦ ,ρ ,x ,(last (consequent proof-e0)))
		                            (last (consequent proof-e1))))]
    ;; Plus
    [`(⇓-plus
       ,proof-e0
       ,proof-e1
       (plus ----- (= (+ ,v0+ ,v1+) ,v-r))
       -----
       ((plus ,e0 ,e1) ,ρ+ ⇓ ,v-r))
     #:when (and (equal? v-r v) (equal? ρ+ ρ))
     (define v0 (last (consequent proof-e0)))
     (define v1 (last (consequent proof-e1)))
     (and (⇓ proof-e0 e0 ρ v0)
          (⇓ proof-e1 e1 ρ v1)
          (equal? v0+ v0)
          (equal? v1+ v1)
          (equal? v-r (nat-add v0 v1)))]
    ;; Not
    [`(⇓-not-0
       ,proof-e0
       -----
       ((not ,e0) ,ρ ⇓ O))
     (define v0+ (match (consequent proof-e0) [`(,_ ,_ ⇓ ,v) v]))
     (and (equal? v0+ v) (not (equal? v 'O)) (⇓ proof-e0 e0 ρ v))]
    [`(⇓-not-1
       ,proof-e0
       -----
       ((not ,e0) ,ρ ⇓ (S O)))
     (define v0+ (match (consequent proof-e0) [`(,_ ,_ ⇓ ,v) v]))
     (and (equal? v0+ v) (equal? v 'O) (⇓ proof-e0 e0 ρ v))]
    ;; If-True
    [`(⇓-if-true
       ,proof-guard-true
       ,proof-e1-v-res
       -----
       ((if0 ,e0 ,e1 ,e2) ,ρ ⇓ ,v))
     (match (consequent proof-guard-true)
       [`(,_ ,_ ⇓ O)
        (and (⇓ proof-guard-true e0 ρ 'O)
             (⇓ proof-e1-v-res e1 ρ v))])]
    ;; If-False
    [`(⇓-if-false
       ,proof-guard-false
       ,proof-e1-v-res
       -----
       ((if0 ,e0 ,e1 ,e2) ,ρ ⇓ ,v+))
     #:when (equal? v+ v)
     (match (consequent proof-guard-false)
       [`(,_ ,_ ⇓ ,n)
        (and (not (equal? n 'O))
             (⇓ proof-guard-false e0 ρ n)
             (⇓ proof-e1-v-res e1 ρ v))])]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;the-programs&quot;&gt;The Programs&lt;/h3&gt;

&lt;p&gt;Compared to the checking, writing the proofs is surprisingly
straightforward—even pleasant (okay; maybe not pleasant). A common
idiom when writing certified (proof-backed) code is the notion of
returning an existential, i.e., a witness alongside its proof. Of
course, the key challenge in writing certified code is convincing
yourself of its correctness.  There are a variety of ways you could do
this: you could inspect the output of the evaluator I write and ensure
that they match the specification, for example. However, for full
clarity, I will use Racket’s contract system, which allows dynamic
checking—this allows us to check the correctness of our evaluators
as we go, but of course won’t prove correctness across all runs, and
using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;define/contract&lt;/code&gt; also interposes the check at &lt;em&gt;every&lt;/em&gt; callsite
(a serious overhead), though I am sure you can use your imagination
about how this could be made faster.&lt;/p&gt;

&lt;p&gt;Let’s start with environments, writing a function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(lookup ρ x)&lt;/code&gt;,
which returns a proof that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; returns some value &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v&lt;/code&gt;–if it doesn’t,
we would just throw a dynamic error due to a match failure–we are
posting a proof exists. We can write a contract to ensure that the
code we use to do this is correct. Racket’s default arrow contract
combinator, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt;, is not powerful enough to express dependent
contracts, where a property of the result depends on one of the
inputs. However, Racket’s more powerful &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&amp;gt;i&lt;/code&gt; does allow dependent
contracts, allowing us to write a version of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lookup&lt;/code&gt; which both
computes what we want and checks to ensure its correctness:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; decision procedure for lookup -- returns witness and proof of inclusion
(define/contract (lookup ρ x)
        ;; v---- domain ----v
    (-&amp;gt;i ([ρ environment?] [x symbol?])
        ;; range -- produces a proof dependent on ρ,x
         [result (ρ x)
                 (match-lambda [`(,(? value? v) . ,pf) (env-maps? pf ρ x v)]
                               [_ #f])])
  (match ρ
    [`(↦ ,ρ1 ,x1 ,v) #:when (equal? x1 x)
                     `(,v . (↦-hit ------ (↦ ,ρ ,x ,v)))]
    [`(↦ ,ρ1 ,x1 ,v) #:when (not (equal? x1 x))
                     (match (lookup ρ1 x)
                       [`(,v . ,pf)
                        `(,v . (↦-miss ,pf ----- (↦ ,ρ1 ,x1 ,v)))])]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Finally, the interpreter itself—unadorned by the ceremony and
pedantics of low-level unification checking—is surprisingly
unintimidating and to-the-point.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; produce a value alongside a proof of its correctness
(define/contract (eval e ρ)
  ;; contract: returns pair of value and proof of its derivation
  (-&amp;gt;i ([e expr?] [ρ environment?])
       [result (e ρ)
               (lambda (witness-pf) (match witness-pf
                                      [`(,(? value? v) . ,pf) (⇓ pf e ρ v)]
                                      [_ #f]))])
  (match e
    [(? nonnegative-integer? n)
     (cons (num-&amp;gt;nat n)
           `(⇓-const
             -----
             (,n ,ρ ⇓ ,(num-&amp;gt;nat n))))]
    [(? symbol? x)
     (match (lookup ρ x)
       [`(,v . ,pf)
        (cons v `(⇓-var
                  ,pf
                  -----
                  (,x ,ρ ⇓ ,v)))])]
    [`(let ,x ,e ,eb)
     (match (eval e ρ)
       [`(,v . ,pf-e)
        (match (eval eb `(↦ ,ρ ,x ,v))
          [`(,v-res . ,pf-v)
           (cons v-res
                 `(⇓-let
                   ,pf-e
                   ,pf-v
                   -----
                   ((let ,x ,e ,eb) ,ρ ⇓ ,v-res)))])])]
    [`(plus ,e0 ,e1)
     (match-define `(,v0 . ,pf-v0) (eval e0 ρ))
     (match-define `(,v1 . ,pf-v1) (eval e1 ρ))
     (define v-res (nat-add v0 v1))
     (cons v-res
           `(⇓-plus
             ,pf-v0
             ,pf-v1
             (plus ----- (= (+ ,v0 ,v1) ,v-res))
             -----
             ((plus ,e0 ,e1) ,ρ ⇓ ,v-res)))]
    [`(not ,e)
     (match (eval e ρ)
       [`(0 . ,pf-e)
        (cons '(S O)
              `(⇓-not-1
                ,pf-e
                -----
                ((not ,e) ρ ⇓ (S O))))]
       [`(,v0 . ,pf-e)
        (cons 'O
              `(⇓-not-0
                ,pf-e
                -----
                ((not ,e) ρ ⇓ O)))])]
    [`(if0 ,e0 ,e1 ,e2)
     (match (eval e0 ρ)
       [`(O . ,pf-e0)
        (match (eval e1 ρ)
          [`(,v . ,pf-v)
           (cons v
                 `(⇓-if-true
                   ,pf-e0
                   ,pf-v
                   -----
                   ((if0 ,e0 ,e1 ,e2) ,ρ ⇓ ,v)))])]
       [`(,n . ,pf-e0)
        (match (eval e2 ρ)
          [`(,v . ,pf-v)
           (cons v
                 `(⇓-if-false
                   ,pf-e0
                   ,pf-v
                   -----
                   ((if0 ,e0 ,e1 ,e2) ,ρ ⇓ ,v)))])])]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;visualizing-our-proofs&quot;&gt;Visualizing our Proofs&lt;/h3&gt;

&lt;p&gt;Alright, so now our interpreter writes proofs–what do they look like?
Thankfully, we used S-expressions.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; nice latex; comment out the labels by adding a % before \\tiny
(define (pf-&amp;gt;tex pf)
  (define name (first pf))
  (define antecedents (reverse (list-tail (reverse (list-tail (cdr pf) 0)) 2)))
  (foldr
   (lambda (k v acc) (string-replace acc k v))
   (format &quot; \n \\frac{ ~a }{ \\texttt{ ~a } }}&quot;
           name
           (string-join (map pf-&amp;gt;tex antecedents) &quot;\\,&quot;)
           (consequent pf))
   '(&quot;⇓&quot; &quot;∅&quot; &quot;↦&quot;)
   '(&quot;\\ensuremath{\\Downarrow}&quot; &quot;\\ensuremath{\\emptyset}&quot; 
     &quot;\\ensuremath{\\mapsto}&quot;)))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here’s the complete derivation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;((plus 1 (if0 0 1 2)))&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/plus-1.png&quot; alt=&quot;Proof of ((plus 1 (if0 0 1 2)))&quot; style=&quot;width:650px&quot; class=&quot;post-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And a longer program where I had to remove the rule names in
rendering…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/longproof.png&quot; alt=&quot;Longer proof&quot; style=&quot;width:650px&quot; class=&quot;post-image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;metatheoretic-concessions-for-the-working-programmer&quot;&gt;Metatheoretic Concessions for the Working Programmer&lt;/h3&gt;

&lt;p&gt;Obviously we would never write an interpreter in Racket the way we did
above: there’s too much extraneous math (i.e., the proof objects). I
think it’s surprising, though, to see how much more direct the code
becomes by (a) erasing the proofs, (b) implementing the environment as
hashes, and (c) relying upon racket’s built-in representation of
numbers. The biggest burden in my implementation is obviously (a), as
I have explicated the proofs via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cons&lt;/code&gt;. Tighter implementations exist
that would hide the ugliness via (say) monads. Eliminating proofs also
eliminates a lot of administrative matching and in some places allows
to make tail calls to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eval&lt;/code&gt; where we couldn’t before, giving us a
textbook metacircular interpreter. I think it is interesting to see
just how directly a translation it is: I systematically removed each
feature (in the same way an extractor would) to achieve the simpler
implementation.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(define (eval-simpl e ρ)
  (match e
    [(? nonnegative-integer? n) n]
    [(? symbol? x) (hash-ref ρ x)]
    [`(let ,x ,e ,eb) (eval-simpl eb (hash-set ρ x (eval-simpl e ρ)))]
    [`(plus ,e0 ,e1) (+ (eval-simpl e0 ρ) (eval-simpl e1 ρ))]
    [`(not ,e)
     (match (eval-simpl e ρ)
       [0 1]
       [_ 0])]
    [`(if0 ,e0 ,e1 ,e2)
     (match (eval-simpl e0 ρ)
       [0 (eval-simpl e1 ρ)]
       [_ (eval-simpl e2 ρ)])]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Do I think this is the future of dependently typed programming? Of
anything? Perhaps both no. Racket is not a particularly appealing
implementation language for type theory and its pattern matching is
not designed to scale to settings where higher-order unification is of
concern to the user. Similarly, this code has serious algorithmic
inefficiencies; plenty of the proof checking could be memoized, and
perhaps some simple contract trick would achieve this (though other
evaluation strategies could, e.g., use tabling in the metatheory). I
largely wrote this up to motivate my thoughts on (the potential of)
explaining the operationalization of proof objects to students as an
extension of operational semantics in the untyped setting I teach in
my class. Perhaps this will help someone draw connections between
operational semantics and proof objects, though I hesitate to say type
theory, broadly.&lt;/p&gt;

&lt;p&gt;Ultimately I did manage to find a lot of bugs in my implementation of
the interpreter using the contracts. Obviously, though, I was driving
the process by generating terms and not using a systematic methodology
of proving the correctness–I have tried to say that the interpreter
generates certificates, but it is of course not certified. It’s a fun
exercise, though–you can read the full code yourself below. I think
there are a few follow ups that could be done from here if you are
interested in experimenting with the code. Adding closures and
application, for example, should not be too hard; I may illustrate
that in my course next term.&lt;/p&gt;

&lt;p&gt;Thanks to Quinn Wilton for some corrections to the phrasing in this
post.&lt;/p&gt;

&lt;h3 id=&quot;the-code&quot;&gt;The Code&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;;; self-certifying interpreters, summer 2022, kris micinski
#lang racket

;; naturals
(define (nat? n)
  (match n ['O #t] [`(S ,(? nat? n)) #t] [_ #f]))

(define/contract (num-&amp;gt;nat n)
  (-&amp;gt; nonnegative-integer? nat?)
  (match n
    [0 'O]
    [n `(S ,(num-&amp;gt;nat (- n 1)))]))

(define/contract (nat-&amp;gt;num n)
  (-&amp;gt; nat? nonnegative-integer?)
  (match n
    ['O 0]
    [`(S ,x) (add1 (nat-&amp;gt;num x))]))

(define/contract (nat-add s0 s1)
  (-&amp;gt; nat? nat? nat?)
  (match s0
    ['O s1]
    [`(S ,s0+) `(S ,(nat-add s0+ s1))]))

;; values are nats
(define value? nat?)

;; expressions
(define (expr? e)
  (match e
    [(? nonnegative-integer? n) #t]
    [(? symbol? x) #t]
    [`(let ,(? symbol? x) ,(? expr? e) ,(? expr? e-body)) #t]
    [`(plus ,(? expr? e0) ,(? expr? e1)) #t]
    [`(not ,(? expr? e-guard)) #t]
    [`(if0 ,(? expr? e0) ,(? expr? e1) ,(? expr? e2)) #t]
    [_ #f]))

;; environments
(define (environment? ρ)
  (match ρ
    ['∅ #t]
    [`(↦ ,(? environment? ρ+) ,(? symbol? x) ,(? value? v)) #t]
    [_ #f]))

;; environment lookup -- predicate (inductive defn.)
(define/contract (env-maps? pf ρ x v)
  (-&amp;gt; any/c environment? symbol? value? boolean?)
  (match pf
    [`(↦-hit
       ------
       (↦ ,ρ ,x0 ,v0))
     (and (equal? x0 x) (equal? v0 v))]
    [`(↦-miss
       ,next-pf
       -----
       (↦ ,ρ ,x0 ,_))
     (and (not (equal? x0 x))
          (env-maps? next-pf ρ x v))]
    [_ #f]))

;; decision procedure for lookup -- returns witness and proof of inclusion
(define/contract (lookup ρ x)
        ;; v---- domain ----v
    (-&amp;gt;i ([ρ environment?] [x symbol?])
        ;; range -- produces a proof dependent on ρ,x
         [result (ρ x)
                 (lambda (witness-pf) (match witness-pf
                                        [`(,(? value? v) . ,pf) (env-maps? pf ρ x v)]
                                        [_ #f]))])
  (match ρ
    [`(↦ ,ρ1 ,x1 ,v) #:when (equal? x1 x)
                     `(,v . (↦-hit ------ (↦ ,ρ ,x ,v)))]
    [`(↦ ,ρ1 ,x1 ,v) #:when (not (equal? x1 x))
                     (match (lookup ρ1 x)
                       [`(,v . ,pf)
                        `(,v . (↦-miss ,pf ----- (↦ ,ρ1 ,x1 ,v) ))])]))

; (lookup '(↦ (↦ ∅ x O) y (S O)) 'x)

;; we will now follow the style '(name atecedent0 ... ----- consequent)
(define (consequent judgement) (last judgement))

;; predicate -- inductive definition of evaluation relation
(define/contract (⇓ pf e ρ v)
  (-&amp;gt; any/c expr? environment? value? boolean?)
  (match pf
    ;; Const
    [`(⇓-const
       -----
       (,(? nonnegative-integer? n) ,ρ+ ⇓ ,v+))
     #:when (and (equal? (num-&amp;gt;nat n) v) (equal? ρ+ ρ) (equal? v v+))
     #t]
    ;; Var
    [`(⇓-var ,proof-x-in-ρ
       -----
       (,(? symbol? x) ,(? environment? ρ+) ⇓ ,(? value? v+)))
     #:when (and (equal? ρ+ ρ) (equal? v+ v))
     (env-maps? proof-x-in-ρ ρ x v)]
    ;; Let
    [`(⇓-let
       ,proof-e0
       ,proof-e1
       -----
       ((let ,(? symbol? x) ,(? expr? e0) ,(? expr? e1)) ,(? environment? ρ+) ⇓ ,(? value? v+)))
     #:when (equal? v+ v) (equal? ρ+ ρ)
     (and (⇓ proof-e0 e0 ρ (last (consequent proof-e0)))
          (⇓ proof-e1 e1 `(↦ ,ρ ,x ,(last (consequent proof-e0))) (last (consequent proof-e1))))]
    ;; Plus
    [`(⇓-plus
       ,proof-e0
       ,proof-e1
       (plus ----- (= (+ ,v0+ ,v1+) ,v-r))
       -----
       ((plus ,e0 ,e1) ,ρ+ ⇓ ,v-r))
     #:when (and (equal? v-r v) (equal? ρ+ ρ))
     (define v0 (last (consequent proof-e0)))
     (define v1 (last (consequent proof-e1)))
     (and (⇓ proof-e0 e0 ρ v0)
          (⇓ proof-e1 e1 ρ v1)
          (equal? v0+ v0)
          (equal? v1+ v1)
          (equal? v-r (nat-add v0 v1)))]
    ;; Not
    [`(⇓-not-0
       ,proof-e0
       -----
       ((not ,e0) ,ρ ⇓ O))
     (define v0+ (match (consequent proof-e0) [`(,_ ,_ ⇓ ,v) v]))
     (and (equal? v0+ v) (not (equal? v 'O)) (⇓ proof-e0 e0 ρ v))]
    [`(⇓-not-1
       ,proof-e0
       -----
       ((not ,e0) ,ρ ⇓ (S O)))
     (define v0+ (match (consequent proof-e0) [`(,_ ,_ ⇓ ,v) v]))
     (and (equal? v0+ v) (equal? v 'O) (⇓ proof-e0 e0 ρ v))]
    ;; If-True
    [`(⇓-if-true
       ,proof-guard-true
       ,proof-e1-v-res
       -----
       ((if0 ,e0 ,e1 ,e2) ,ρ ⇓ ,v))
     (match (consequent proof-guard-true)
       [`(,_ ,_ ⇓ O)
        (and (⇓ proof-guard-true e0 ρ 'O)
             (⇓ proof-e1-v-res e1 ρ v))])]
    ;; If-False
    [`(⇓-if-false
       ,proof-guard-false
       ,proof-e1-v-res
       -----
       ((if0 ,e0 ,e1 ,e2) ,ρ ⇓ ,v+))
     #:when (equal? v+ v)
     (match (consequent proof-guard-false)
       [`(,_ ,_ ⇓ ,n)
        (and (not (equal? n 'O))
             (⇓ proof-guard-false e0 ρ n)
             (⇓ proof-e1-v-res e1 ρ v))])]
    [_ #f]))

;;
;; Self-certifying interpreter
;;

;; produce a value alongside a proof of its correctness
(define/contract (eval e ρ)
  ;; contract: returns pair of value and proof of its derivation
  (-&amp;gt;i ([e expr?] [ρ environment?])
       [result (e ρ)
               (lambda (witness-pf) (match witness-pf
                                      [`(,(? value? v) . ,pf) (⇓ pf e ρ v)]
                                      [_ #f]))])
  (match e
    [(? nonnegative-integer? n)
     (cons (num-&amp;gt;nat n)
           `(⇓-const
             -----
             (,n ,ρ ⇓ ,(num-&amp;gt;nat n))))]
    [(? symbol? x)
     (match (lookup ρ x)
       [`(,v . ,pf)
        (cons v `(⇓-var
                  ,pf
                  -----
                  (,x ,ρ ⇓ ,v)))])]
    [`(let ,x ,e ,eb)
     (match (eval e ρ)
       [`(,v . ,pf-e)
        (match (eval eb `(↦ ,ρ ,x ,v))
          [`(,v-res . ,pf-v)
           (cons v-res
                 `(⇓-let
                   ,pf-e
                   ,pf-v
                   -----
                   ((let ,x ,e ,eb) ,ρ ⇓ ,v-res)))])])]
    [`(plus ,e0 ,e1)
     (match-define `(,v0 . ,pf-v0) (eval e0 ρ))
     (match-define `(,v1 . ,pf-v1) (eval e1 ρ))
     (define v-res (nat-add v0 v1))
     (cons v-res
           `(⇓-plus
             ,pf-v0
             ,pf-v1
             (plus ----- (= (+ ,v0 ,v1) ,v-res))
             -----
             ((plus ,e0 ,e1) ,ρ ⇓ ,v-res)))]
    [`(not ,e)
     (match (eval e ρ)
       [`(0 . ,pf-e)
        (cons '(S O)
              `(⇓-not-1
                ,pf-e
                -----
                ((not ,e) ρ ⇓ (S O))))]
       [`(,v0 . ,pf-e)
        (cons 'O
              `(⇓-not-0
                ,pf-e
                -----
                ((not ,e) ρ ⇓ O)))])]
    [`(if0 ,e0 ,e1 ,e2)
     (match (eval e0 ρ)
       [`(O . ,pf-e0)
        (match (eval e1 ρ)
          [`(,v . ,pf-v)
           (cons v
                 `(⇓-if-true
                   ,pf-e0
                   ,pf-v
                   -----
                   ((if0 ,e0 ,e1 ,e2) ,ρ ⇓ ,v)))])]
       [`(,n . ,pf-e0)
        (match (eval e2 ρ)
          [`(,v . ,pf-v)
           (cons v
                 `(⇓-if-false
                   ,pf-e0
                   ,pf-v
                   -----
                   ((if0 ,e0 ,e1 ,e2) ,ρ ⇓ ,v)))])])]))

;; nice latex; comment out the labels by adding a % before \\tiny
(define (pf-&amp;gt;tex pf)
  (define name (first pf))
  (define antecedents (reverse (list-tail (reverse (list-tail (cdr pf) 0)) 2)))
  (foldr
   (lambda (k v acc) (string-replace acc k v))
   (format &quot; \n \\frac{ ~a }{ \\texttt{ ~a } }}&quot;
           name
           (string-join (map pf-&amp;gt;tex antecedents) &quot;\\,&quot;)
           (consequent pf))
   '(&quot;⇓&quot; &quot;∅&quot; &quot;↦&quot;)
   '(&quot;\\ensuremath{\\Downarrow}&quot; &quot;\\ensuremath{\\emptyset}&quot; &quot;\\ensuremath{\\mapsto}&quot;)))

(define (derive e)
  (displayln (pf-&amp;gt;tex (cdr (eval e '∅)))))

;; examples

;(derive '(let x (plus 0 (if0 (plus 0 0) 1 0)) (plus x 0)))
;(derive '(plus 1 (if0 0 1 2)))
;(derive '(let x (plus 0 0) (plus x 1)))

(define (eval-simpl e ρ)
  (match e
    [(? nonnegative-integer? n) n]
    [(? symbol? x) (hash-ref ρ x)]
    [`(let ,x ,e ,eb)
     (eval-simpl eb (hash-set ρ x (eval-simpl e ρ)))]
    [`(plus ,e0 ,e1) (+ (eval-simpl e0 ρ) (eval-simpl e1 ρ))]
    [`(not ,e)
     (match (eval-simpl e ρ)
       [0 1]
       [_ 0])]
    [`(if0 ,e0 ,e1 ,e2)
     (match (eval-simpl e0 ρ)
       [0 (eval-simpl e1 ρ)]
       [_ (eval-simpl e2 ρ)])]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sun, 14 Aug 2022 00:00:00 -0400</pubDate>
        <link>/certifying-interpreters</link>
        <guid isPermaLink="true">/certifying-interpreters</guid>
        
        
        <category>dependent-types,</category>
        
        <category>functional-programming,</category>
        
        <category>theorem-proving</category>
        
      </item>
    
      <item>
        <title>Why I hope you'll submit to Scheme Workshop</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://thomas.gilray.org/scheme-2019/&quot;&gt;&lt;strong&gt;Link to this year’s Scheme Workshop CFP&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This year marks the twentieth anniversary of the workshop on &lt;a href=&quot;http://www.schemeworkshop.org/&quot;&gt;Scheme
and Functional Programming&lt;/a&gt;. The
Scheme Workshop represents a diverse community of hackers, academics,
and enthusiasts. The workshop offers a forum to share insights,
experience, and technical developments of and within the Scheme family
of programming languages. Rather than focus on a specific
implementation or community, workshop attendees are united by an
appreciation for succinct expression of novel ideas realized via
programming. The submission deadline is &lt;strong&gt;May 24th, 2019&lt;/strong&gt;, I hope
you’ll help us celebrate by submitting a paper!&lt;/p&gt;

&lt;h4 id=&quot;what-is-scheme-workshop&quot;&gt;What is Scheme Workshop?&lt;/h4&gt;

&lt;p&gt;The Scheme Workshop website describes it as a…&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Yearly meeting of programming language practitioners who share an
  aesthetic sense embodied by the Algorithmic Language Scheme:
  universality through minimalism, and flexibility through rigorous
  design.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here’s my personal take. I love Scheme Workshop because it brings
together a group of people with a truly unique perspective on
programming. We represent a diverse background, but a shared vision:
to distill insights about programming to their most economic
presentation. We appreciate thoughtful, comprehensible solutions to
challenging problems. We challenge ourselves to step outside of our
boundaries and build fundamentally new paradigms for expressing
ideas. Our mission is to build a community where we foster diversity,
education, and support each other in pursuit of these ideals.&lt;/p&gt;

&lt;p&gt;Scheme Workshop is unique in that it is:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Open to everyone who cares about Scheme-ish ideas&lt;/strong&gt;. Instead of
   focusing on promoting the most cutting edge results, Scheme
   Workshop centers around thoughtful discussions relating to unique
   ideas that embody the ethos of Scheme. You don’t have to be an
   academic to attend; in fact, we have a rich history of
   participation from hobbyists and industrial attendees.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Non-archival and open access&lt;/strong&gt;. We aim to support and foster unique
  ideas. Naturally, some of these ideas may grow into work
  eventually submitted to research conferences. Scheme Workshop
  provides a platform for researchers to get perspective from the
  Scheme community on their work at all stages of development. While
  we publish a technical report of submitted papers, submission to
  Scheme Workshop does not preclude subsequent submission to
  archival research conferences. In fact, we see Scheme Workshop as
  an ideal proving ground for groundbreaking research ideas. We hope
  that the discussions generated by the presentation of those ideas
  at Scheme Workshop will productively inform the authors’
  scholarship.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Supportive of off-the-wall ideas&lt;/strong&gt;. There are some ideas that
  are really interesting, kind of zany, and just inspire us in a
  deep way we can’t quite put our finger on. These ideas aren’t
  necessarily the kind that would fit well at a programming-oriented
  conference, but they might not be a good fit for research
  conferences either. Scheme Workshop is a perfect venue for these
  kinds of ideas. You’ll find like-minded people who enjoy
  challenging their perspectives on what programming even means.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;A great place for your first paper&lt;/strong&gt;. We place an emphasis on
  giving thoughtful, high-quality, and friendly reviews. We also
  have a strong appreciation for “half-baked” ideas. When I was a
  beginning PhD student, submitting to so-called top conferences
  often felt overwhelming. Scheme Workshop wants to help budding
  researchers develop their writing and presentation. Similarly, we
  realize that great ideas can come from people in industry, the
  open-source community, or the broader hobbyist community. We work
  hard to ensure that their ideas are taken seriously and give them
  the feedback they deserve.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;what-about-racket-haskell-clojure-sml-c-etc&quot;&gt;What about Racket, Haskell, Clojure, SML, C++, etc…?&lt;/h4&gt;

&lt;p&gt;The language isn’t what’s important, it’s the idea. We want the
workshop to be filled with exciting talks that broaden our horizons
and challenge us to think about programming in a way we wouldn’t have
before. I could easily imagine relevant papers dealing with template
metaprogramming in C++, hygiene in OCaml, or domain-specific languages
in Clojure.&lt;/p&gt;

&lt;p&gt;If you think your idea &lt;em&gt;might&lt;/em&gt; be relevant to the workshop, please
don’t hesitate to contact Tom and myself. We’ll gladly give you
an honest assessment of whether your idea would be a good fit. If not,
we’ll do our best to direct you towards an appropriate venue for your
ideas.&lt;/p&gt;

&lt;h4 id=&quot;who-should-submit&quot;&gt;Who should submit?&lt;/h4&gt;

&lt;p&gt;Traditionally, submissions to Scheme Workshop come from those within
or adjacent to academia. However, this is &lt;strong&gt;not&lt;/strong&gt; a requirement. We
welcome submissions from everyone who thinks they have something
thoughtful to say to the Scheme community. This year, I want to
specifically encourage submissions from:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Undergraduate or graduate students who are looking for practice
writing papers on their own. It can be a challenge to develop your
own sense of research style. Scheme Workshop is a great place to get
feedback on your work in a low-stakes environment. Rather than judge
the quality of your work against a high technical bar, we want to
help build your ideas and presentation so that you can be proud of
the way you’re articulating them.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;People within the tech industry who have never written an academic
paper before. Scheme Workshop leans a bit more academic than
conferences such as RacketCon and StrangeLoop. However, this doesn’t
mean we don’t value ideas from industry. If you’re in industry and
would like to write a paper but aren’t sure how, please reach out to
me: I’m happy to Skype with you and speak frankly about how the
process works.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Seasoned Scheme wizards. Scheme Workshop has a long history of
insightful talks from key contributors to the Scheme community. These
community members shape our vision, and guide newcomers (such as
myself!) by helping us understand the key principles that embody the
Scheme community.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;some-random-scheme-workshop-papers-i-liked&quot;&gt;Some random Scheme Workshop papers I liked&lt;/h4&gt;

&lt;p&gt;There’s truly been some amazing work at Scheme Workshop over the
years.  I can’t hope to summarize it all here. Instead, I picked a
random collection of papers to help you get an idea of the workshop’s
direction.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://schemeworkshop.org/2006/15-barzilay.pdf&quot;&gt;A Self-Hosting Evaluator using
HOAS&lt;/a&gt;, by Eli
Barzilay. This paper discusses how–when you’re implementing a
Scheme interpreter in Scheme–you can avoid implementing
substitution by reflecting lambdas from the source language into the
metalangauge (which still gives you means of abstracting, e.g.,
control structure). This is a neat idea that is the perfect size for
Scheme Workshop.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://scheme2006.cs.uchicago.edu/03-mccarthy.pdf&quot;&gt;Interaction-Safe State for the
Web&lt;/a&gt; by Jay
McCarthy and Shriram Krishnamurthi. This paper discusses new
linguistic mechanisms for building abstractions for how we
understand navigation within web applications. I think this idea
nicely combines the practice of building web applications correctly
with the linguistic abstraction mechanisms afforded by Scheme.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://users.cs.northwestern.edu/~robby/pubs/papers/scheme2007-wf.pdf&quot;&gt;Well-typed programs can’t be
blamed&lt;/a&gt;
by Philip Wadler and Robby Findler. This paper from 2007 appears to
be an earlier version of the highly influential 2009 ESOP paper of the
same name.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.ccs.neu.edu/home/dherman/research/papers/scheme08-stack-marks.pdf&quot;&gt;Implementing Continuations Marks in
JavaScript&lt;/a&gt;
by John Clements, Ayswarya Sundaram, and David Herman. This paper
discusses how continuation marks can be implemented in JavaScript. I
see this as an exciting paper exploring a novel idea in a new space,
and the authors mention some foundational challenges in scaling up
to languages that allow tail calls with conventional “return”-style
semantics.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://users.soe.ucsc.edu/~lkuper/papers/lambdae.pdf&quot;&gt;A pattern matcher for miniKanren–or–How to get into trouble with
CPS macros&lt;/a&gt;
by Andy Keep, Michael Adams, Lindsey Kuper, Will Byrd, and Dan
Friedman. This paper reveals an interesting ramification of writing
macros in a CPS-based style alongside conditional macro
expansion. They build a pattern matcher for the miniKanren
programming language, demonstrating the issue along the way. I like
that this paper reveals a foundational problem in macro engineering.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;help-us-build-a-community&quot;&gt;Help us build a community!&lt;/h4&gt;

&lt;p&gt;The goal of Scheme Workshop is to build a community that celebrates
the fun in presenting beautifully minimal ideas. We often masquerade
these ideas as programs. But we’re all bound together by the passion
we share for articulating our ideas in an elegant way. Programming
languages give us the ability to rapidly interact with our ideas,
breaking and rebuilding our realization of those ideas at a pace never
before seen by humanity. Scheme celebrates this opportunity by
allowing us unprecedented flexibility in the way we articulate and
execute these ideas.&lt;/p&gt;

&lt;p&gt;I hope that you share my excitement. If you do, I sincerely hope
you’ll consider submitting a paper to &lt;a href=&quot;https://thomas.gilray.org/scheme-2019/&quot;&gt;the twentieth workshop on
Scheme and Functional
Programming&lt;/a&gt;!&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Apr 2019 00:00:00 -0400</pubDate>
        <link>/research/functional-programming/scheme/2019/04/10/scheme-workshop/</link>
        <guid isPermaLink="true">/research/functional-programming/scheme/2019/04/10/scheme-workshop/</guid>
        
        
        <category>research</category>
        
        <category>functional-programming</category>
        
        <category>scheme</category>
        
      </item>
    
      <item>
        <title>Why Does Netflix See my Facebook Picture?</title>
        <description>&lt;p&gt;The other day I updated my Facebook profile picture. The thing I
didn’t realize was that when I changed it, Netflix also got it:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/facebook-netflix.png&quot; alt=&quot;A figure showing my Facebook profile picture on the left with an arrow pointing towards Netflix (getting my updated Facebook photo) on the right with a question mark over it (asking why)&quot; style=&quot;width:450px&quot; class=&quot;post-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This is pretty jarring. Where was the “share this with Netflix” button
that I pressed? Of course, the answer is that it’s right here:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/netflix-privacy.png&quot; alt=&quot;A picture of Facebook's privacy configuration for Netflix&quot; style=&quot;width:350px&quot; class=&quot;post-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It’s buried right there under “Public profile (required).” But there’s
also a lot of other stuff I gave it access to too, I guess I forgot
about that.&lt;/p&gt;

&lt;p&gt;But why does it need access to my Facebook account at all? I just
wanted to use Facebook so that I wouldn’t have to login to Netflix
using an email. It’s so easy to just click in with my Facebook
account, it’s everywhere!&lt;/p&gt;

&lt;p&gt;The answer, of course, is twofold: Netflix wants to give me a more
personalized experience (so they can beat out other video services)
and because they want to filter it into giant machine learning
algorithms to sell me ads and learn stuff about me.&lt;/p&gt;

&lt;p&gt;So I knew all of that, but I &lt;em&gt;still&lt;/em&gt; didn’t stop and think about
Netflix getting my new profile picture whenever I changed it. Wow. I
wonder what else does that!&lt;/p&gt;

&lt;p&gt;Turns out it’s &lt;em&gt;hundreds&lt;/em&gt; of things! Facebook even has a tool for
this, called their “Privacy Checkup”:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/facebook-privacy-checkup.png&quot; alt=&quot;A picture of Facebook's privacy checkup tool&quot; style=&quot;width:400px&quot; class=&quot;post-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This is useful for helping you audit which apps have access to do
things like post on your feed and things like that. But it doesn’t
show you more nuanced things.&lt;/p&gt;

&lt;p&gt;Here’s the big problem with all of this:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;There’s a gap between what Netflix is actually &lt;strong&gt;using&lt;/strong&gt;, and what I
think it &lt;strong&gt;needs&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When I think about Netflix using my Facebook, I think it’s just
because I’m logging on. But what I don’t see is that Netflix is using
so much more! It’s connecting me with my friends, looking at my likes,
and using that information to improve my experience.&lt;/p&gt;

&lt;p&gt;And what’s more, Netflix probably thinks that it’s okay to do this,
because after all, I agreed to it! And to be honest, they’re not
totally wrong.&lt;/p&gt;

&lt;p&gt;But I build my mental model of what Netflix is accessing based on what
I &lt;em&gt;see&lt;/em&gt; it doing, not the policy that I have to go read in a dark
corner of Facebook’s privacy section (no offense to Facebook).&lt;/p&gt;

&lt;h2 id=&quot;background-uses-are-tricky&quot;&gt;Background Uses Are Tricky&lt;/h2&gt;

&lt;p&gt;I contend that the main problem here is that humans are very poor at
envisioning how apps will use our information in the “background.” The
background is a hazy thing, but by the background I basically mean,
“during a time at which I haven’t directly instructed the app to use
my information by an explicit interaction (e.g., pressing a button)”&lt;/p&gt;

&lt;p&gt;Humans are very &lt;em&gt;good&lt;/em&gt; at understanding that their information will be
used after taking some direct action. For example, after I click
“share location” it’s extremely obvious that my location will be
used. But we’re really bad at predicting (or remembering) what might
happen when it’s been six months since we installed the app.&lt;/p&gt;

&lt;p&gt;Here’s another example I noticed just today. I added some new contacts
to the phone book on my iPhone. Later, I went to use Skype. I’m not a
big fan of Skype: every other week it seems like someone’s Skype
account has been hacked, so I can’t say I have a huge amount of trust
in it. Of course, when Skype installed it basically forced me to allow
it to access my contacts. Okay, that seems sensible, so I let it. But
I didn’t realize that it would &lt;em&gt;constantly&lt;/em&gt; get my contacts whenever I
changed them. I allowed access, of course, but I didn’t really “see”
Skype accessing my contacts, so why would I be surprised.&lt;/p&gt;

&lt;p&gt;We found the same result in &lt;a href=&quot;http://kmicinski.com/assets/apptracer.pdf&quot;&gt;my CHI ‘17
paper&lt;/a&gt;, where we measured
user expectations of permission usage within a set of vignette Android
apps. Users were overwhelmingly more likely to expect access to
permissions after they took a direct action, but were much less likely
to expect that data was being accessed when that data was used in the
background. (I’ll be giving this talk again at &lt;a href=&quot;https://www.ftc.gov/news-events/events-calendar/2018/02/privacycon-2018&quot;&gt;PrivacyCon
2018&lt;/a&gt;
later this year!)&lt;/p&gt;

&lt;p&gt;And that was just for apps! Imagine how complicated it is when you’re
not just on your phone, you’re using some nebulous cloud-based
service. What’s worse: most apps have many different components,
interact with several different APIs (Facebook, Google, Twitter,
etc…), each of them using their own privacy GUIs that constantly
update and change.&lt;/p&gt;

&lt;p&gt;My frank guess is that users don’t really have any idea what’s
happening until they see it. In fact, in our CHI ‘17 paper we also
found that users are more likely to expect access when they see some
indication of it (e.g., a banner on the top of the screen associated
with the use of that permission, like a “free coffee at your local
MegaCoffee” coupon). But that’s not very satisfying: what about all of
the other data access they never even see?&lt;/p&gt;

&lt;h2 id=&quot;possible-solutions-better-defaults-reminders-and-audits&quot;&gt;Possible Solutions: Better Defaults, Reminders, and Audits&lt;/h2&gt;

&lt;p&gt;I’m not sure what all of the answers are, but I have a few high-level
points that I take away from it:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Users are very poor at reasoning about data access when the access
is far removed from the authorization decision.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;They are even &lt;em&gt;worse&lt;/em&gt; when there’s no apparent &lt;em&gt;reason&lt;/em&gt; why the
access occurs. In fact, this is almost downright
malicious. Permissions are only so coarse, and while Netflix has
access to a bunch of things in my “public profile”, I’d never expect
it to use all of them (even though I know it does).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We should educate users on how / why background uses occur, and
explain their relevance to app behavior if possible.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;When we’re using coarse permissions, like “Public Profile”, we
should realize that users will only expect a subset of that data to
be used and act accordingly.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So the first thing I think we can do is better defaults. For example,
Apple seems to have taken this hint. Apps can now simply request data
never and “when in use”. This is a pretty intuitive thing, since users
are pretty poor at conceptualizing the computational models of
apps. They also go a step further and show you this nice dialog when
apps have been using data in the background (I’m honestly not sure how
this occurs on iOS these days):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/ios-bg-loc.jpg&quot; alt=&quot;A picture showing how iOS alerts users to background location usage&quot; style=&quot;width:200px&quot; class=&quot;post-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This is nice because it helps the user “audit” which apps have been
using their data. In our paper, we found that one concrete way to help
users understand background usage on Android was to ask for permission
right on startup before any other app functionality appeared. My
hypothesis is that users said “well the app hasn’t done anything yet,
so it must just need this all the time.” Still, I think that’s not a
very good compromise: users will tend to associate that the
information is only being used when the app appears to be using it. So
we should really confine data access to when users can observe it
happening.&lt;/p&gt;

&lt;p&gt;Another concrete way I see this improving is better auditing tools to
help users understand where their data will go. For example, I could
imagine implementing a tool that goes through your various social
networks and plays something like 20-questions with you: “do you know
that when you change your Facebook picture your FindMeSingles apps is
going to see it?” or something of the like. We’d need to do research
to help understand the best examples to present, but I think this
would be a cool idea since users reason well about examples and bad
about very general policies.&lt;/p&gt;

&lt;p&gt;A few research-y things I’m working on right now address this in a few
ways:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Using dynamic analysis to measure when social media permissions are
being used in apps. We’re in the early stages of this (still
scraping apps from Google Play, let me know if you know of a better
way / a good way to get a bunch of apps!), but I think this will
provide some good ground truth on how apps are using these social
media permissions. Of course, there are limitations here. For
example, apps could pair with a web service to do the dirty work,
but I think this is a good first step.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Log-guided program analysis that helps analysts understand &lt;em&gt;why&lt;/em&gt;
apps use permissions. Our tools use relatively cheap tricks to
enable (unsound) program analyses to scale to very large apps
(Bumble, Tinder, Slack) and precisely explain why permissions are
used. We do this by using &lt;em&gt;logs&lt;/em&gt; from those programs to guide the
analysis.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Analysis-based support for lowering the performance overhead of
dynamic information-flow analyses. Since many web systems are
written using dynamic languages (e.g., Python), I’m excited about
the possibilities of using off-the-shelf tools (like
&lt;a href=&quot;https://github.com/jeanqasaur/jeeves&quot;&gt;Jeeves&lt;/a&gt;) to specify
information-flow policies that connect up to the GUI in a principled
way (similar to what I did in &lt;a href=&quot;http://kmicinski.com/assets/clickrelease.pdf&quot;&gt;my ESORICS ‘15
paper&lt;/a&gt;). The problem
with these systems is that they do induce some runtime overhead, but
we’re hoping to eliminate much of that by using intelligent program
analysis techniques.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Longer-term, I’m interested in driving my research to understand how
users conceptualize these permissions. What does that say about how we
can visualize and enforce them? I’m specifically interested in
cross-app policies: where the data goes from the camera app on your
phone, to Instagram, to your friend’s parents after your friend clicks
“like” on the image (and their parents then see it in their
feed). These decisions are nuanced, and seem especially hard to
explain to users. But as we have more and more apps, I think getting a
handle on these things will be essential. And once we do that, we can
(hopefully) start using cool language-based techniques to help enforce
these policies!&lt;/p&gt;
</description>
        <pubDate>Tue, 02 Jan 2018 00:00:00 -0500</pubDate>
        <link>/privacy/research/2018/01/02/privacy-user-understanding/</link>
        <guid isPermaLink="true">/privacy/research/2018/01/02/privacy-user-understanding/</guid>
        
        
        <category>privacy</category>
        
        <category>research</category>
        
      </item>
    
      <item>
        <title>Video: Exploiting Use After Free (UAF) vulnerabilities</title>
        <description>&lt;p&gt;&lt;strong&gt;Obligatory&lt;/strong&gt;: I must point out that my inspiration for this post was
a &lt;a href=&quot;https://www.youtube.com/watch?v=ZHghwsTRyzQ&quot;&gt;really nice video on
YouTube&lt;/a&gt;. I don’t claim
to have invented this idea, I just wanted to explain it in a way that
makes sense to me (although the YouTuber likely does a better job than
I).&lt;/p&gt;

&lt;p&gt;Today in my class we talked a bit about memory safety and
allocation. We’ve talked a decent amount about pointers, but haven’t
had any projects where students are required to use
allocation. Instead, we’re (so far) relying on RAII from library
classes to get students through their programming. My suspcion is that
students are probably too eager to use pointers without understandign
their vagaries, because that’s what I did when I started programming
in C.&lt;/p&gt;

&lt;p&gt;So as a bit of fun (and preparation for my course next semester), I
made a video showing how these vulnerabilities work.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Here’s a &lt;a href=&quot;https://github.com/kmicinski/cmsc245examples/blob/master/c%2B%2B/uaf.cc&quot;&gt;link to the code&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Here’s a &lt;a href=&quot;https://hc.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=6a2b42fb-4e24-4837-8220-97935db6a53b&quot;&gt;link to the video&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 10 Nov 2017 00:00:00 -0500</pubDate>
        <link>/security/videos/memory-safety/use-after-free/2017/11/10/uaf/</link>
        <guid isPermaLink="true">/security/videos/memory-safety/use-after-free/2017/11/10/uaf/</guid>
        
        
        <category>security</category>
        
        <category>videos</category>
        
        <category>memory-safety</category>
        
        <category>use-after-free</category>
        
      </item>
    
      <item>
        <title>Job materials for 2017</title>
        <description>&lt;p&gt;I’m applying to colleges and universities again in 2017. I’m very
happy at Haverford, but I’m on the lookout for a tenure-track spot at
a place that has students and colleagues that will excite me in the
same way I’m feeling right now:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/assets/research.pdf&quot;&gt;My research statement (4 12-point pages)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/assets/teaching.pdf&quot;&gt;My teaching statement (2 12-point pages)&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 09 Nov 2017 00:00:00 -0500</pubDate>
        <link>/application</link>
        <guid isPermaLink="true">/application</guid>
        
        
        <category>git</category>
        
        <category>talks</category>
        
      </item>
    
      <item>
        <title>All About Git</title>
        <description>&lt;p&gt;I’m giving a college-wide talk for FIG (Fig is Good) tonight. FIG is a
student computing group. I’m hoping to record the talk, but for now
I’ll just put the slides here.&lt;/p&gt;

&lt;iframe src=&quot;https://www.icloud.com/keynote/0dhlSy84VggwTIhJdxjvGiTOQ?embed=true&quot; width=&quot;640&quot; height=&quot;500&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;1&quot; referrer=&quot;no-referrer&quot;&gt;&lt;/iframe&gt;
</description>
        <pubDate>Thu, 09 Nov 2017 00:00:00 -0500</pubDate>
        <link>/git/talks/2017/11/09/git-tutorial/</link>
        <guid isPermaLink="true">/git/talks/2017/11/09/git-tutorial/</guid>
        
        
        <category>git</category>
        
        <category>talks</category>
        
      </item>
    
      <item>
        <title>My new cybersecurity course at Haverford (Spring 2017)</title>
        <description>&lt;p&gt;You can also download this syllabus as a &lt;a href=&quot;/assets/cybersec-syllabus.pdf&quot;&gt;PDF&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;computer-security-attacks-and-defenses&quot;&gt;Computer Security: Attacks and Defenses&lt;/h2&gt;
&lt;p&gt;(&lt;em&gt;CMSC 323&lt;/em&gt; at Haverford)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Prerequisites&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Experience in C programming:
    &lt;ul&gt;
      &lt;li&gt;E.g., CMSC245 at Haverford or CMSC246 at Bryn Mawr&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Experience with or willingness to learn learn new languages (Python, SQL, JavaScript, etc..)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Workload&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;3 lecture hours per week&lt;/li&gt;
  &lt;li&gt;1 lab hour per week&lt;/li&gt;
  &lt;li&gt;This will be a lab / project intensive class. Approximately 6-10
hours per week &lt;em&gt;outside&lt;/em&gt; of class will be expected from
students. I recommend against taking this course concurrent with
other project-heavy courses.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Cap&lt;/strong&gt;: 25 (may be lifted to 35)&lt;/p&gt;

&lt;h2 id=&quot;course-overview&quot;&gt;Course Overview&lt;/h2&gt;

&lt;p&gt;This​ ​course​ ​will​ ​serve​ ​as​ ​a​ ​broad​ ​introduction​ ​to​ ​the​ ​field​ ​of​
​computer​ ​security,​ ​from​ ​two concurrent​ ​perspectives:​ ​attacks​ ​on​
​systems,​ ​and​ ​defenses​ ​against​ ​those​ ​attacks.​ ​The​ ​goal​ ​of this​ ​course​
​will​ ​be​ ​to​ ​help​ ​build​ ​intuition​ ​so​ ​that–when​ ​designing​ ​your​ ​own​
​systems–you​ ​can intelligently​ ​assess​ ​and​ ​mitigate​ ​security​ ​risks.&lt;/p&gt;

&lt;p&gt;To​ ​understand​ ​how​ ​attackers​ ​think,​ ​we​ ​will​ ​learn​ ​about​ ​the​ ​attacks​
​they​ ​employ.​ ​​ ​We​ ​will dissect​ ​a​ ​number​ ​of​ ​real-world​ ​attacks​ ​(such​ ​as​
​Heartbleed​ ​or​ ​WannaCry)​ ​and​ ​reflect​ ​upon​ ​what could​ ​have​ ​been​ ​done​ ​to​
​prevent​ ​them.​ ​But​ ​understanding​ ​a​ ​collection​ ​of​ ​attacks​ ​is​ ​not​ ​alone
sufficient​ ​for​ ​helping​ ​us​ ​understand​ ​how​ ​to​ ​build​ ​secure​ ​systems.​ ​So​
​alongside​ ​attacks,​ ​we​ ​will also​ ​learn​ ​the​ ​theoretical​ ​underpinnings​
​of​ ​security,​ ​and​ ​use​ ​it​ ​to​ ​build​ ​defenses​ ​into​ ​our systems.&lt;/p&gt;

&lt;p&gt;Labs​ ​will​ ​transition​ ​theory​ ​into​ ​practice.​ ​We​ ​will​ ​conclude​ ​with​ ​a​
​group​ ​project​ ​exploring advanced​ ​topics​ ​relevant​ ​to​ ​the​ ​state​ ​of​ ​the​
​art​ ​in​ ​computer​ ​security.​ ​The​ ​course​ ​will​ ​begin​ ​with a​ ​discussion​ ​on​
​ethical​ ​application​ ​of​ ​techniques​ ​we​ ​learn.&lt;/p&gt;

&lt;h2 id=&quot;topics&quot;&gt;Topics&lt;/h2&gt;

&lt;p&gt;We​ ​will​ ​cover​ ​parts​ ​of​ ​the​ ​following​ ​topics,​ ​adjusted​ ​for​ ​time​ ​and​ ​pace​ ​of​ ​the​ ​course,​ ​along​ ​with
student​ ​interest​ ​in​ ​each​ ​area.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Low-level​ ​memory​ ​attacks​ ​and​ ​defenses
    &lt;ul&gt;
      &lt;li&gt;Buffer​ ​overflows&lt;/li&gt;
      &lt;li&gt;Stack​ ​canaries&lt;/li&gt;
      &lt;li&gt;Access​ ​space​ ​randomization​ ​/​ ​derandomization&lt;/li&gt;
      &lt;li&gt;Return​ ​to​ ​libc​ ​/​ ​return-oriented-programming&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Cryptography
    &lt;ul&gt;
      &lt;li&gt;Symmetric and asymmetric-key cryptography&lt;/li&gt;
      &lt;li&gt;Certificates, CAs, and​ ​PKI&lt;/li&gt;
      &lt;li&gt;SSL/TLS&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Web security
    &lt;ul&gt;
      &lt;li&gt;SQL​ ​injections&lt;/li&gt;
      &lt;li&gt;Cross-site​ ​scripting&lt;/li&gt;
      &lt;li&gt;Cross-site​ ​request​ ​forgery&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Social​ ​engineering​ ​and​ ​security​ ​ethics&lt;/li&gt;
  &lt;li&gt;UI​ ​design​ ​for​ ​security
    &lt;ul&gt;
      &lt;li&gt;App​ ​permissions​ ​design&lt;/li&gt;
      &lt;li&gt;Best​ ​practices​ ​for​ ​security​ ​UI&lt;/li&gt;
      &lt;li&gt;Permission​ ​lifetime​ ​and​ ​revocation&lt;/li&gt;
      &lt;li&gt;Case​ ​study​ ​in​ ​privacy​ ​controls:
        &lt;ul&gt;
          &lt;li&gt;Facebook​ ​privacy​ ​controls&lt;/li&gt;
          &lt;li&gt;Android​ ​permissions&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Information​ ​flow​ ​control​ ​in​ ​web​ ​apps&lt;/li&gt;
  &lt;li&gt;Reverse​ ​engineering&lt;/li&gt;
  &lt;li&gt;Theoretical​ ​underpinnings​ ​of​ ​security
    &lt;ul&gt;
      &lt;li&gt;Full​ ​abstraction&lt;/li&gt;
      &lt;li&gt;Information​ ​flow&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;projects-and-labs&quot;&gt;Projects and Labs&lt;/h2&gt;

&lt;p&gt;Projects​ ​will​ ​be​ ​started​ ​in​ ​labs,​ ​and​ ​then​ ​continued​ ​individually.​
​Some​ ​labs​ ​are​ ​structured​ ​so​ ​that they​ ​begin​ ​with​ ​a​ ​concrete​
​assignment​ ​to​ ​work​ ​on​ ​as​ ​an​ ​individual​ ​in​ ​the​ ​first​ ​week,​ ​and​ ​then
move​ ​on​ ​to​ ​a​ ​group​ ​assignment​ ​to​ ​complete​ ​a​ ​larger​ ​task.&lt;/p&gt;

&lt;h4 id=&quot;project-1-memory-attacks-weeks-1-4-inclusive-uses-c-programming&quot;&gt;Project 1: Memory attacks (Weeks 1-4 inclusive) (Uses C programming)&lt;/h4&gt;

&lt;p&gt;This​ ​project​ ​will​ ​cover​ ​low-level​ ​memory​ ​attacks​ ​using​ ​the​ ​C​
​programming​ ​language.​ ​The students​ ​will​ ​begin​ ​by​ ​executing​ ​an​ ​attack​
​from​ ​starter​ ​code​ ​provided.​ ​They​ ​will​ ​then​ ​implement their​ ​own​ ​buffer​
​overflow​ ​attack,​ ​and​ ​demonstrate​ ​a​ ​way​ ​to​ ​prevent​ ​the​ ​attack​ ​by​
​intelligent programming,​ ​and​ ​also​ ​facilities​ ​provided​ ​by​ ​the​
​compiler.​ ​After​ ​completing​ ​this​ ​task,​ ​students will​ ​form​ ​groups​ ​to​
​complete​ ​a​ ​more​ ​advanced​ ​attack​ ​studying​ ​ASLR​ ​or​ ​ROP.​ ​1.5​ ​weeks​ ​will​
​be allocated​ ​for​ ​independent​ ​programming,​ ​and​ ​1.5​ ​weeks​ ​will​ ​be​
​allocated​ ​for​ ​group​ ​work.&lt;/p&gt;

&lt;h4 id=&quot;project-2-cryptography-weeks-4-7-incl-uses-python-programming&quot;&gt;Project 2: Cryptography (weeks 4-7 incl.) (Uses Python programming)&lt;/h4&gt;

&lt;p&gt;This​ ​project​ ​will​ ​involve​ ​creating​ ​a​ ​public​ ​/​ ​private​ ​key​ ​pair​ ​and​
​manually​ ​exchanging​ ​keys​ ​to collaborate​ ​secretly​ ​communicate​ ​with​
​group​ ​members.​ ​The​ ​next​ ​week,​ ​students​ ​will​ ​either implement​ ​a​ ​secure​
​chat​ ​using​ ​cryptographic​ ​primitives​ ​provided,​ ​or​ ​explore​ ​an​ ​attack​ ​on​
​an insecure​ ​cryptographic​ ​hash.&lt;/p&gt;

&lt;h4 id=&quot;project-3-web-security-weeks-7-9-incl-uses-python-programming&quot;&gt;Project 3: Web security (weeks 7-9 incl.) (Uses Python programming)&lt;/h4&gt;

&lt;p&gt;Students​ ​will​ ​be​ ​given​ ​an​ ​insecure​ ​web​ ​app​ ​written​ ​in​ ​Python​ ​which​ ​is​
​vulnerable​ ​to​ ​an​ ​SQL injection​ ​attack.​ ​They​ ​will​ ​then​ ​craft​ ​an​ ​input​
​which​ ​causes​ ​the​ ​app​ ​to​ ​leak​ ​secret​ ​information​ ​(in this​ ​case,​
​student​ ​grades​ ​from​ ​a​ ​synthetic​ ​gradebook​ ​consisting​ ​of​ ​fictitious​
​students).​ ​They​ ​will then​ ​fix​ ​this​ ​attack​ ​in​ ​the​ ​app.​ ​Finally,​
​students​ ​will​ ​attempt​ ​to​ ​break​ ​other​ ​students’​ ​fixes.&lt;/p&gt;

&lt;h4 id=&quot;final-project-weeks-10-14&quot;&gt;Final project (weeks 10-14):&lt;/h4&gt;

&lt;p&gt;This​ ​will​ ​be​ ​a​ ​final​ ​project,​ ​either​ ​in​ ​a​ ​group​ ​or​ ​alone.​ ​Students​ ​requesting​ ​to​ ​work​ ​alone​ ​need
prior​ ​approval​ ​for​ ​a​ ​topic​ ​and​ ​expectations​ ​will​ ​be​ ​calibrated​ ​accordingly.​ ​Students​ ​will​ ​select
one​ ​of​ ​the​ ​following​ ​projects,​ ​or​ ​propose​ ​their​ ​own​ ​project:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Information flow specification (uses Python/Jeeves)&lt;/p&gt;

    &lt;p&gt;Implement​ ​privacy​ ​policies​ ​for​ ​a​ ​secure​ ​student​ ​grades​ ​database​
​using​ ​Jeeves,​ ​an extension​ ​to​ ​the​ ​Python​ ​programming​ ​language.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Designing a privacy UI (uses Python / Javascript / etc..)&lt;/p&gt;

    &lt;p&gt;Use​ ​best​ ​practices​ ​to​ ​propose​ ​and​ ​implement​ ​a​ ​new​ ​UI​ ​for​ ​some​ ​privacy-related
mechanism,​ ​and​ ​perform​ ​a​ ​mock​ ​implementation.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Malware reverse engineering&lt;/p&gt;

    &lt;p&gt;Use​ ​reverse​ ​engineering​ ​tools​ ​to​ ​understand​ ​and​ ​discuss​ ​how​ ​a​
​particular​ ​piece​ ​of malware​ ​works.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Implement signature-based antivirus&lt;/p&gt;

    &lt;p&gt;Students​ ​will​ ​read​ ​about​ ​and​ ​implement​ ​a​ ​variant​ ​of​ ​signature-based​
​antivirus​ ​detection for​ ​a​ ​small​ ​sample​ ​of​ ​malware.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Students​ ​will​ ​check​ ​in​ ​with​ ​the​ ​professor​ ​regularly,​ ​and​
collaboration​ ​will​ ​occur​ ​via​ ​Github.&lt;/p&gt;

&lt;h2 id=&quot;grading&quot;&gt;Grading&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Labs and projects: 50%
    &lt;ul&gt;
      &lt;li&gt;Individual component: 30%&lt;/li&gt;
      &lt;li&gt;Group component: 20%&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Two midterm exams: 30% (take home and open note)
    &lt;ul&gt;
      &lt;li&gt;Given 1/3rd and 2/3rd of the way through the course&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Final project: 20%&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Evaluation​ ​for​ ​group​ ​projects​ ​will​ ​be​ ​based​ ​on​ ​mutual​ ​student​
feedback​ ​and​ ​oral​ ​exam​ ​with individual​ ​group​ ​members.&lt;/p&gt;

&lt;h2 id=&quot;books&quot;&gt;Books&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Required&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Security Engineering, Second Editing&lt;/strong&gt;, ​by ​Ross ​Anderson
    &lt;ul&gt;
      &lt;li&gt;This​ ​book​ ​is​ ​freely​ ​available​ ​online​ ​from​ ​the​ ​author&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Online​ ​resources​ ​will​ ​be​ ​distributed​ ​throughout​ ​the​ ​course.​ ​These​
​include​ ​blog​ ​articles (e.g.,​ ​by​ ​the​ ​Facebook​ ​privacy​ ​group),​ ​academic​
​papers,​ ​and​ ​websites​ ​(e.g.,​ ​the​ ​Android security​ ​internals).​ ​These​
​will​ ​all​ ​be​ ​freely​ ​available.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Optional&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;The Web Application Hacker’s Handbook&lt;/strong&gt;​,​ ​by​ ​Dafydd​ ​Stuttard​ ​&amp;amp;​ ​Marcus​ ​Pinto&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Applied Cryptography, Second Edition&lt;/strong&gt;, by​ ​Bruce​ ​Schneier&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 23 Sep 2017 00:00:00 -0400</pubDate>
        <link>/teaching/2017/09/23/my-cybersecurity-course/</link>
        <guid isPermaLink="true">/teaching/2017/09/23/my-cybersecurity-course/</guid>
        
        
        <category>teaching</category>
        
      </item>
    
      <item>
        <title>Writing tip: say the text back to you</title>
        <description>&lt;p&gt;Here’s the tip: have your computer read your writing back to
you. Listen to how it sounds. Then, iterate until it conveys what
you’d like to hear. On a mac, you can do this it like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;say -r words_per_minute &quot;My speech goes here&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I do this to either:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Read the text back to me quickly (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-r 240-270&lt;/code&gt;). This helps follow
along with a document in front of me and check it for flow. It also
catches miswordings, (some) grammar errors, and typos.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Close my eyes, sit back, and really try to absorb the text. I listen
slowly, around 180-200 words per minute. This allows me to hear
places where the text sounds awkward or redundant.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The book &lt;a href=&quot;https://www.amazon.com/BUGS-Writing-Revised-Guide-Debugging/dp/020137921X&quot;&gt;BUGS in
Writing&lt;/a&gt;
talks at length about developing an “ear” for good writing. While I
found the book’s content useful, it’s decidedly hard to be able to
objectively “hear” your own writing. I have a tough time divorcing the
process of reading from pondering over the endless ways I could
improve any given sentence.&lt;/p&gt;

&lt;p&gt;I’ve found that listening to the text spoken back to you is a great
way to perform rapid prototyping on documents. For example, I wrote a
rough draft of this post, listened to it, and then restructured based
on what I heard. I don’t think of myself as a naturally good
writer. Forcing myself to slow down and concentrate naturally shifts
my sentences towards being shorter and more concise.&lt;/p&gt;

&lt;p&gt;Here’s an example from the syllabus for my upcoming security course,
which I was editing today:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;To understand how attackers think, we will learn about the attacks
they employ. But understanding a collection of attacks is not alone
sufficient for helping us understand how to build secure systems. So
alongside attacks, we will also cover the theory behind building
defenses into our systems. We will dissect a number of real-world
attacks (such as Heartbleed or WannaCry) and reflect upon what could
have been done to prevent them. To complement these examples, will
learn the theoretical underpinnings of security that apply across
systems.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I spent some amount of time going over this text, but never really
“heard” it all together. When I did, I immediately identified the
problem: the paragraph was saying the same thing twice, breaking the
natural flow.&lt;/p&gt;

&lt;p&gt;I then came up with this:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;To understand how attackers think, we will learn about the attacks
they employ. We will dissect a number of real-world attacks (such as
Heartbleed or WannaCry) and reflect upon what could have been done
to prevent them. But understanding a collection of attacks is not
alone sufficient for helping us understand how to build secure
systems. So alongside attacks, we will also learn the theoretical
underpinnings of security, and use it to build defenses into our
systems.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Which sounds a lot better to me!&lt;/p&gt;

&lt;p&gt;By the way, I learned this trick from Philip Guo:&lt;/p&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;en&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;Do other people do this too? I often use text-to-speech to have my computer/phone read my own writing back to me to sense how it sounds&lt;/p&gt;&amp;mdash; Philip Guo (@pgbovine) &lt;a href=&quot;https://twitter.com/pgbovine/status/910182577767514113&quot;&gt;September 19, 2017&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

</description>
        <pubDate>Fri, 22 Sep 2017 00:00:00 -0400</pubDate>
        <link>/writing/2017/09/22/reading-text-back/</link>
        <guid isPermaLink="true">/writing/2017/09/22/reading-text-back/</guid>
        
        
        <category>writing</category>
        
      </item>
    
      <item>
        <title>How to Succeed in Grad School</title>
        <description>&lt;p&gt;I gave this talk on August 24, 2017, to incoming grad students at the
University of Maryland, College Park.  Full slides available
&lt;a href=&quot;/assets/gradschoolsuccess.key&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;iframe src=&quot;https://www.icloud.com/keynote/021F6CUaWtKuou6byPrV-aYvg?embed=true&quot; width=&quot;640&quot; height=&quot;500&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;1&quot; referrer=&quot;no-referrer&quot;&gt;&lt;/iframe&gt;
</description>
        <pubDate>Fri, 01 Sep 2017 00:00:00 -0400</pubDate>
        <link>/talks/grad-school/2017/09/01/how-to-succeed-in-grad-school/</link>
        <guid isPermaLink="true">/talks/grad-school/2017/09/01/how-to-succeed-in-grad-school/</guid>
        
        
        <category>talks</category>
        
        <category>grad-school</category>
        
      </item>
    
  </channel>
</rss>
